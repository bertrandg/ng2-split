{"version":3,"sources":["webpack:///scripts.1a98e92f27987b318cfc.bundle.js","webpack:////home/adebisi/Public/ng2-split/~/script-loader/addScript.js","webpack:////home/adebisi/Public/ng2-split/~/prismjs/prism.js?14ae","webpack:////home/adebisi/Public/ng2-split/~/split.js/split.js?2e12","webpack:////home/adebisi/Public/ng2-split/~/prismjs/prism.js","webpack:////home/adebisi/Public/ng2-split/~/split.js/split.js"],"names":["webpackJsonp","371","module","exports","src","execScript","eval","call","374","__webpack_require__","375","648","649","677"],"mappings":"AAAAA,cAAc,EAAE,IAEVC,IACA,SAASC,EAAQC,GCCvBD,EAAAC,QAAA,SAAAC,GACA,mBAAAC,YACAA,WAAAD,GAEAE,KAAAC,KAAA,KAAAH,KDWMI,IACA,SAASN,EAAQC,EAASM,GEpBhCA,EAAA,KAAAA,EAAA,OF0BMC,IACA,SAASR,EAAQC,EAASM,GG3BhCA,EAAA,KAAAA,EAAA,OHiCME,IACA,SAAST,EAAQC,GIlCvBD,EAAAC,QAAA,g6qBJwCMS,IACA,SAASV,EAAQC,GKzCvBD,EAAAC,QAAA;EL+CMU,IACA,SAASX,EAAQC,EAASM,GAEhCA,EAAoB,KACpBP,EAAOC,QAAUM,EAAoB,QAKlC","file":"scripts.1a98e92f27987b318cfc.bundle.js","sourcesContent":["webpackJsonp([2,3],{\n\n/***/ 371:\n/***/ function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n/***/ },\n\n/***/ 374:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(371)(__webpack_require__(648))\n\n/***/ },\n\n/***/ 375:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(371)(__webpack_require__(649))\n\n/***/ },\n\n/***/ 648:\n/***/ function(module, exports) {\n\nmodule.exports = \"\\n/* **********************************************\\n     Begin prism-core.js\\n********************************************** */\\n\\nvar _self = (typeof window !== 'undefined')\\n\\t? window   // if in browser\\n\\t: (\\n\\t\\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\\n\\t\\t? self // if in worker\\n\\t\\t: {}   // if in node js\\n\\t);\\n\\n/**\\n * Prism: Lightweight, robust, elegant syntax highlighting\\n * MIT license http://www.opensource.org/licenses/mit-license.php/\\n * @author Lea Verou http://lea.verou.me\\n */\\n\\nvar Prism = (function(){\\n\\n// Private helper vars\\nvar lang = /\\\\blang(?:uage)?-(\\\\w+)\\\\b/i;\\nvar uniqueId = 0;\\n\\nvar _ = _self.Prism = {\\n\\tutil: {\\n\\t\\tencode: function (tokens) {\\n\\t\\t\\tif (tokens instanceof Token) {\\n\\t\\t\\t\\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\\n\\t\\t\\t} else if (_.util.type(tokens) === 'Array') {\\n\\t\\t\\t\\treturn tokens.map(_.util.encode);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\\\u00a0/g, ' ');\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\ttype: function (o) {\\n\\t\\t\\treturn Object.prototype.toString.call(o).match(/\\\\[object (\\\\w+)\\\\]/)[1];\\n\\t\\t},\\n\\n\\t\\tobjId: function (obj) {\\n\\t\\t\\tif (!obj['__id']) {\\n\\t\\t\\t\\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\\n\\t\\t\\t}\\n\\t\\t\\treturn obj['__id'];\\n\\t\\t},\\n\\n\\t\\t// Deep clone a language definition (e.g. to extend it)\\n\\t\\tclone: function (o) {\\n\\t\\t\\tvar type = _.util.type(o);\\n\\n\\t\\t\\tswitch (type) {\\n\\t\\t\\t\\tcase 'Object':\\n\\t\\t\\t\\t\\tvar clone = {};\\n\\n\\t\\t\\t\\t\\tfor (var key in o) {\\n\\t\\t\\t\\t\\t\\tif (o.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\t\\t\\tclone[key] = _.util.clone(o[key]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn clone;\\n\\n\\t\\t\\t\\tcase 'Array':\\n\\t\\t\\t\\t\\t// Check for existence for IE8\\n\\t\\t\\t\\t\\treturn o.map && o.map(function(v) { return _.util.clone(v); });\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn o;\\n\\t\\t}\\n\\t},\\n\\n\\tlanguages: {\\n\\t\\textend: function (id, redef) {\\n\\t\\t\\tvar lang = _.util.clone(_.languages[id]);\\n\\n\\t\\t\\tfor (var key in redef) {\\n\\t\\t\\t\\tlang[key] = redef[key];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn lang;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Insert a token before another token in a language literal\\n\\t\\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\\n\\t\\t * we cannot just provide an object, we need anobject and a key.\\n\\t\\t * @param inside The key (or language id) of the parent\\n\\t\\t * @param before The key to insert before. If not provided, the function appends instead.\\n\\t\\t * @param insert Object with the key/value pairs to insert\\n\\t\\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\\n\\t\\t */\\n\\t\\tinsertBefore: function (inside, before, insert, root) {\\n\\t\\t\\troot = root || _.languages;\\n\\t\\t\\tvar grammar = root[inside];\\n\\n\\t\\t\\tif (arguments.length == 2) {\\n\\t\\t\\t\\tinsert = arguments[1];\\n\\n\\t\\t\\t\\tfor (var newToken in insert) {\\n\\t\\t\\t\\t\\tif (insert.hasOwnProperty(newToken)) {\\n\\t\\t\\t\\t\\t\\tgrammar[newToken] = insert[newToken];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn grammar;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar ret = {};\\n\\n\\t\\t\\tfor (var token in grammar) {\\n\\n\\t\\t\\t\\tif (grammar.hasOwnProperty(token)) {\\n\\n\\t\\t\\t\\t\\tif (token == before) {\\n\\n\\t\\t\\t\\t\\t\\tfor (var newToken in insert) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif (insert.hasOwnProperty(newToken)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tret[newToken] = insert[newToken];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tret[token] = grammar[token];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update references in other language definitions\\n\\t\\t\\t_.languages.DFS(_.languages, function(key, value) {\\n\\t\\t\\t\\tif (value === root[inside] && key != inside) {\\n\\t\\t\\t\\t\\tthis[key] = ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn root[inside] = ret;\\n\\t\\t},\\n\\n\\t\\t// Traverse a language definition with Depth First Search\\n\\t\\tDFS: function(o, callback, type, visited) {\\n\\t\\t\\tvisited = visited || {};\\n\\t\\t\\tfor (var i in o) {\\n\\t\\t\\t\\tif (o.hasOwnProperty(i)) {\\n\\t\\t\\t\\t\\tcallback.call(o, i, o[i], type || i);\\n\\n\\t\\t\\t\\t\\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\\n\\t\\t\\t\\t\\t\\tvisited[_.util.objId(o[i])] = true;\\n\\t\\t\\t\\t\\t\\t_.languages.DFS(o[i], callback, null, visited);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\\n\\t\\t\\t\\t\\t\\tvisited[_.util.objId(o[i])] = true;\\n\\t\\t\\t\\t\\t\\t_.languages.DFS(o[i], callback, i, visited);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\tplugins: {},\\n\\n\\thighlightAll: function(async, callback) {\\n\\t\\tvar env = {\\n\\t\\t\\tcallback: callback,\\n\\t\\t\\tselector: 'code[class*=\\\"language-\\\"], [class*=\\\"language-\\\"] code, code[class*=\\\"lang-\\\"], [class*=\\\"lang-\\\"] code'\\n\\t\\t};\\n\\n\\t\\t_.hooks.run(\\\"before-highlightall\\\", env);\\n\\n\\t\\tvar elements = env.elements || document.querySelectorAll(env.selector);\\n\\n\\t\\tfor (var i=0, element; element = elements[i++];) {\\n\\t\\t\\t_.highlightElement(element, async === true, env.callback);\\n\\t\\t}\\n\\t},\\n\\n\\thighlightElement: function(element, async, callback) {\\n\\t\\t// Find language\\n\\t\\tvar language, grammar, parent = element;\\n\\n\\t\\twhile (parent && !lang.test(parent.className)) {\\n\\t\\t\\tparent = parent.parentNode;\\n\\t\\t}\\n\\n\\t\\tif (parent) {\\n\\t\\t\\tlanguage = (parent.className.match(lang) || [,''])[1].toLowerCase();\\n\\t\\t\\tgrammar = _.languages[language];\\n\\t\\t}\\n\\n\\t\\t// Set language on the element, if not present\\n\\t\\telement.className = element.className.replace(lang, '').replace(/\\\\s+/g, ' ') + ' language-' + language;\\n\\n\\t\\t// Set language on the parent, for styling\\n\\t\\tparent = element.parentNode;\\n\\n\\t\\tif (/pre/i.test(parent.nodeName)) {\\n\\t\\t\\tparent.className = parent.className.replace(lang, '').replace(/\\\\s+/g, ' ') + ' language-' + language;\\n\\t\\t}\\n\\n\\t\\tvar code = element.textContent;\\n\\n\\t\\tvar env = {\\n\\t\\t\\telement: element,\\n\\t\\t\\tlanguage: language,\\n\\t\\t\\tgrammar: grammar,\\n\\t\\t\\tcode: code\\n\\t\\t};\\n\\n\\t\\t_.hooks.run('before-sanity-check', env);\\n\\n\\t\\tif (!env.code || !env.grammar) {\\n\\t\\t\\t_.hooks.run('complete', env);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t_.hooks.run('before-highlight', env);\\n\\n\\t\\tif (async && _self.Worker) {\\n\\t\\t\\tvar worker = new Worker(_.filename);\\n\\n\\t\\t\\tworker.onmessage = function(evt) {\\n\\t\\t\\t\\tenv.highlightedCode = evt.data;\\n\\n\\t\\t\\t\\t_.hooks.run('before-insert', env);\\n\\n\\t\\t\\t\\tenv.element.innerHTML = env.highlightedCode;\\n\\n\\t\\t\\t\\tcallback && callback.call(env.element);\\n\\t\\t\\t\\t_.hooks.run('after-highlight', env);\\n\\t\\t\\t\\t_.hooks.run('complete', env);\\n\\t\\t\\t};\\n\\n\\t\\t\\tworker.postMessage(JSON.stringify({\\n\\t\\t\\t\\tlanguage: env.language,\\n\\t\\t\\t\\tcode: env.code,\\n\\t\\t\\t\\timmediateClose: true\\n\\t\\t\\t}));\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\\n\\n\\t\\t\\t_.hooks.run('before-insert', env);\\n\\n\\t\\t\\tenv.element.innerHTML = env.highlightedCode;\\n\\n\\t\\t\\tcallback && callback.call(element);\\n\\n\\t\\t\\t_.hooks.run('after-highlight', env);\\n\\t\\t\\t_.hooks.run('complete', env);\\n\\t\\t}\\n\\t},\\n\\n\\thighlight: function (text, grammar, language) {\\n\\t\\tvar tokens = _.tokenize(text, grammar);\\n\\t\\treturn Token.stringify(_.util.encode(tokens), language);\\n\\t},\\n\\n\\ttokenize: function(text, grammar, language) {\\n\\t\\tvar Token = _.Token;\\n\\n\\t\\tvar strarr = [text];\\n\\n\\t\\tvar rest = grammar.rest;\\n\\n\\t\\tif (rest) {\\n\\t\\t\\tfor (var token in rest) {\\n\\t\\t\\t\\tgrammar[token] = rest[token];\\n\\t\\t\\t}\\n\\n\\t\\t\\tdelete grammar.rest;\\n\\t\\t}\\n\\n\\t\\ttokenloop: for (var token in grammar) {\\n\\t\\t\\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar patterns = grammar[token];\\n\\t\\t\\tpatterns = (_.util.type(patterns) === \\\"Array\\\") ? patterns : [patterns];\\n\\n\\t\\t\\tfor (var j = 0; j < patterns.length; ++j) {\\n\\t\\t\\t\\tvar pattern = patterns[j],\\n\\t\\t\\t\\t\\tinside = pattern.inside,\\n\\t\\t\\t\\t\\tlookbehind = !!pattern.lookbehind,\\n\\t\\t\\t\\t\\tgreedy = !!pattern.greedy,\\n\\t\\t\\t\\t\\tlookbehindLength = 0,\\n\\t\\t\\t\\t\\talias = pattern.alias;\\n\\n\\t\\t\\t\\tpattern = pattern.pattern || pattern;\\n\\n\\t\\t\\t\\tfor (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop\\n\\n\\t\\t\\t\\t\\tvar str = strarr[i];\\n\\n\\t\\t\\t\\t\\tif (strarr.length > text.length) {\\n\\t\\t\\t\\t\\t\\t// Something went terribly wrong, ABORT, ABORT!\\n\\t\\t\\t\\t\\t\\tbreak tokenloop;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (str instanceof Token) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tpattern.lastIndex = 0;\\n\\n\\t\\t\\t\\t\\tvar match = pattern.exec(str),\\n\\t\\t\\t\\t\\t    delNum = 1;\\n\\n\\t\\t\\t\\t\\t// Greedy patterns can override/remove up to two previously matched tokens\\n\\t\\t\\t\\t\\tif (!match && greedy && i != strarr.length - 1) {\\n\\t\\t\\t\\t\\t\\t// Reconstruct the original text using the next two tokens\\n\\t\\t\\t\\t\\t\\tvar nextToken = strarr[i + 1].matchedStr || strarr[i + 1],\\n\\t\\t\\t\\t\\t\\t    combStr = str + nextToken;\\n\\n\\t\\t\\t\\t\\t\\tif (i < strarr.length - 2) {\\n\\t\\t\\t\\t\\t\\t\\tcombStr += strarr[i + 2].matchedStr || strarr[i + 2];\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Try the pattern again on the reconstructed text\\n\\t\\t\\t\\t\\t\\tpattern.lastIndex = 0;\\n\\t\\t\\t\\t\\t\\tmatch = pattern.exec(combStr);\\n\\t\\t\\t\\t\\t\\tif (!match) {\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar from = match.index + (lookbehind ? match[1].length : 0);\\n\\t\\t\\t\\t\\t\\t// To be a valid candidate, the new match has to start inside of str\\n\\t\\t\\t\\t\\t\\tif (from >= str.length) {\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tvar to = match.index + match[0].length,\\n\\t\\t\\t\\t\\t\\t    len = str.length + nextToken.length;\\n\\n\\t\\t\\t\\t\\t\\t// Number of tokens to delete and replace with the new match\\n\\t\\t\\t\\t\\t\\tdelNum = 3;\\n\\n\\t\\t\\t\\t\\t\\tif (to <= len) {\\n\\t\\t\\t\\t\\t\\t\\tif (strarr[i + 1].greedy) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tdelNum = 2;\\n\\t\\t\\t\\t\\t\\t\\tcombStr = combStr.slice(0, len);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstr = combStr;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (!match) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif(lookbehind) {\\n\\t\\t\\t\\t\\t\\tlookbehindLength = match[1].length;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar from = match.index + lookbehindLength,\\n\\t\\t\\t\\t\\t    match = match[0].slice(lookbehindLength),\\n\\t\\t\\t\\t\\t    to = from + match.length,\\n\\t\\t\\t\\t\\t    before = str.slice(0, from),\\n\\t\\t\\t\\t\\t    after = str.slice(to);\\n\\n\\t\\t\\t\\t\\tvar args = [i, delNum];\\n\\n\\t\\t\\t\\t\\tif (before) {\\n\\t\\t\\t\\t\\t\\targs.push(before);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);\\n\\n\\t\\t\\t\\t\\targs.push(wrapped);\\n\\n\\t\\t\\t\\t\\tif (after) {\\n\\t\\t\\t\\t\\t\\targs.push(after);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tArray.prototype.splice.apply(strarr, args);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn strarr;\\n\\t},\\n\\n\\thooks: {\\n\\t\\tall: {},\\n\\n\\t\\tadd: function (name, callback) {\\n\\t\\t\\tvar hooks = _.hooks.all;\\n\\n\\t\\t\\thooks[name] = hooks[name] || [];\\n\\n\\t\\t\\thooks[name].push(callback);\\n\\t\\t},\\n\\n\\t\\trun: function (name, env) {\\n\\t\\t\\tvar callbacks = _.hooks.all[name];\\n\\n\\t\\t\\tif (!callbacks || !callbacks.length) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (var i=0, callback; callback = callbacks[i++];) {\\n\\t\\t\\t\\tcallback(env);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nvar Token = _.Token = function(type, content, alias, matchedStr, greedy) {\\n\\tthis.type = type;\\n\\tthis.content = content;\\n\\tthis.alias = alias;\\n\\t// Copy of the full string this token was created from\\n\\tthis.matchedStr = matchedStr || null;\\n\\tthis.greedy = !!greedy;\\n};\\n\\nToken.stringify = function(o, language, parent) {\\n\\tif (typeof o == 'string') {\\n\\t\\treturn o;\\n\\t}\\n\\n\\tif (_.util.type(o) === 'Array') {\\n\\t\\treturn o.map(function(element) {\\n\\t\\t\\treturn Token.stringify(element, language, o);\\n\\t\\t}).join('');\\n\\t}\\n\\n\\tvar env = {\\n\\t\\ttype: o.type,\\n\\t\\tcontent: Token.stringify(o.content, language, parent),\\n\\t\\ttag: 'span',\\n\\t\\tclasses: ['token', o.type],\\n\\t\\tattributes: {},\\n\\t\\tlanguage: language,\\n\\t\\tparent: parent\\n\\t};\\n\\n\\tif (env.type == 'comment') {\\n\\t\\tenv.attributes['spellcheck'] = 'true';\\n\\t}\\n\\n\\tif (o.alias) {\\n\\t\\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\\n\\t\\tArray.prototype.push.apply(env.classes, aliases);\\n\\t}\\n\\n\\t_.hooks.run('wrap', env);\\n\\n\\tvar attributes = '';\\n\\n\\tfor (var name in env.attributes) {\\n\\t\\tattributes += (attributes ? ' ' : '') + name + '=\\\"' + (env.attributes[name] || '') + '\\\"';\\n\\t}\\n\\n\\treturn '<' + env.tag + ' class=\\\"' + env.classes.join(' ') + '\\\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\\n\\n};\\n\\nif (!_self.document) {\\n\\tif (!_self.addEventListener) {\\n\\t\\t// in Node.js\\n\\t\\treturn _self.Prism;\\n\\t}\\n \\t// In worker\\n\\t_self.addEventListener('message', function(evt) {\\n\\t\\tvar message = JSON.parse(evt.data),\\n\\t\\t    lang = message.language,\\n\\t\\t    code = message.code,\\n\\t\\t    immediateClose = message.immediateClose;\\n\\n\\t\\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\\n\\t\\tif (immediateClose) {\\n\\t\\t\\t_self.close();\\n\\t\\t}\\n\\t}, false);\\n\\n\\treturn _self.Prism;\\n}\\n\\n//Get current script and highlight\\nvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\\\"script\\\")).pop();\\n\\nif (script) {\\n\\t_.filename = script.src;\\n\\n\\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\\n\\t\\tif(document.readyState !== \\\"loading\\\") {\\n\\t\\t\\trequestAnimationFrame(_.highlightAll, 0);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\\n\\t\\t}\\n\\t}\\n}\\n\\nreturn _self.Prism;\\n\\n})();\\n\\nif (typeof module !== 'undefined' && module.exports) {\\n\\tmodule.exports = Prism;\\n}\\n\\n// hack for components to work correctly in node.js\\nif (typeof global !== 'undefined') {\\n\\tglobal.Prism = Prism;\\n}\\n\\n\\n/* **********************************************\\n     Begin prism-markup.js\\n********************************************** */\\n\\nPrism.languages.markup = {\\n\\t'comment': /<!--[\\\\w\\\\W]*?-->/,\\n\\t'prolog': /<\\\\?[\\\\w\\\\W]+?\\\\?>/,\\n\\t'doctype': /<!DOCTYPE[\\\\w\\\\W]+?>/,\\n\\t'cdata': /<!\\\\[CDATA\\\\[[\\\\w\\\\W]*?]]>/i,\\n\\t'tag': {\\n\\t\\tpattern: /<\\\\/?(?!\\\\d)[^\\\\s>\\\\/=.$<]+(?:\\\\s+[^\\\\s>\\\\/=]+(?:=(?:(\\\"|')(?:\\\\\\\\\\\\1|\\\\\\\\?(?!\\\\1)[\\\\w\\\\W])*\\\\1|[^\\\\s'\\\">=]+))?)*\\\\s*\\\\/?>/i,\\n\\t\\tinside: {\\n\\t\\t\\t'tag': {\\n\\t\\t\\t\\tpattern: /^<\\\\/?[^\\\\s>\\\\/]+/i,\\n\\t\\t\\t\\tinside: {\\n\\t\\t\\t\\t\\t'punctuation': /^<\\\\/?/,\\n\\t\\t\\t\\t\\t'namespace': /^[^\\\\s>\\\\/:]+:/\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\t'attr-value': {\\n\\t\\t\\t\\tpattern: /=(?:('|\\\")[\\\\w\\\\W]*?(\\\\1)|[^\\\\s>]+)/i,\\n\\t\\t\\t\\tinside: {\\n\\t\\t\\t\\t\\t'punctuation': /[=>\\\"']/\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\t'punctuation': /\\\\/?>/,\\n\\t\\t\\t'attr-name': {\\n\\t\\t\\t\\tpattern: /[^\\\\s>\\\\/]+/,\\n\\t\\t\\t\\tinside: {\\n\\t\\t\\t\\t\\t'namespace': /^[^\\\\s>\\\\/:]+:/\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t},\\n\\t'entity': /&#?[\\\\da-z]{1,8};/i\\n};\\n\\n// Plugin to make entity title show the real entity, idea by Roman Komarov\\nPrism.hooks.add('wrap', function(env) {\\n\\n\\tif (env.type === 'entity') {\\n\\t\\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\\n\\t}\\n});\\n\\nPrism.languages.xml = Prism.languages.markup;\\nPrism.languages.html = Prism.languages.markup;\\nPrism.languages.mathml = Prism.languages.markup;\\nPrism.languages.svg = Prism.languages.markup;\\n\\n\\n/* **********************************************\\n     Begin prism-css.js\\n********************************************** */\\n\\nPrism.languages.css = {\\n\\t'comment': /\\\\/\\\\*[\\\\w\\\\W]*?\\\\*\\\\//,\\n\\t'atrule': {\\n\\t\\tpattern: /@[\\\\w-]+?.*?(;|(?=\\\\s*\\\\{))/i,\\n\\t\\tinside: {\\n\\t\\t\\t'rule': /@[\\\\w-]+/\\n\\t\\t\\t// See rest below\\n\\t\\t}\\n\\t},\\n\\t'url': /url\\\\((?:([\\\"'])(\\\\\\\\(?:\\\\r\\\\n|[\\\\w\\\\W])|(?!\\\\1)[^\\\\\\\\\\\\r\\\\n])*\\\\1|.*?)\\\\)/i,\\n\\t'selector': /[^\\\\{\\\\}\\\\s][^\\\\{\\\\};]*?(?=\\\\s*\\\\{)/,\\n\\t'string': /(\\\"|')(\\\\\\\\(?:\\\\r\\\\n|[\\\\w\\\\W])|(?!\\\\1)[^\\\\\\\\\\\\r\\\\n])*\\\\1/,\\n\\t'property': /(\\\\b|\\\\B)[\\\\w-]+(?=\\\\s*:)/i,\\n\\t'important': /\\\\B!important\\\\b/i,\\n\\t'function': /[-a-z0-9]+(?=\\\\()/i,\\n\\t'punctuation': /[(){};:]/\\n};\\n\\nPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);\\n\\nif (Prism.languages.markup) {\\n\\tPrism.languages.insertBefore('markup', 'tag', {\\n\\t\\t'style': {\\n\\t\\t\\tpattern: /(<style[\\\\w\\\\W]*?>)[\\\\w\\\\W]*?(?=<\\\\/style>)/i,\\n\\t\\t\\tlookbehind: true,\\n\\t\\t\\tinside: Prism.languages.css,\\n\\t\\t\\talias: 'language-css'\\n\\t\\t}\\n\\t});\\n\\t\\n\\tPrism.languages.insertBefore('inside', 'attr-value', {\\n\\t\\t'style-attr': {\\n\\t\\t\\tpattern: /\\\\s*style=(\\\"|').*?\\\\1/i,\\n\\t\\t\\tinside: {\\n\\t\\t\\t\\t'attr-name': {\\n\\t\\t\\t\\t\\tpattern: /^\\\\s*style/i,\\n\\t\\t\\t\\t\\tinside: Prism.languages.markup.tag.inside\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t'punctuation': /^\\\\s*=\\\\s*['\\\"]|['\\\"]\\\\s*$/,\\n\\t\\t\\t\\t'attr-value': {\\n\\t\\t\\t\\t\\tpattern: /.+/i,\\n\\t\\t\\t\\t\\tinside: Prism.languages.css\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\talias: 'language-css'\\n\\t\\t}\\n\\t}, Prism.languages.markup.tag);\\n}\\n\\n/* **********************************************\\n     Begin prism-clike.js\\n********************************************** */\\n\\nPrism.languages.clike = {\\n\\t'comment': [\\n\\t\\t{\\n\\t\\t\\tpattern: /(^|[^\\\\\\\\])\\\\/\\\\*[\\\\w\\\\W]*?\\\\*\\\\//,\\n\\t\\t\\tlookbehind: true\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tpattern: /(^|[^\\\\\\\\:])\\\\/\\\\/.*/,\\n\\t\\t\\tlookbehind: true\\n\\t\\t}\\n\\t],\\n\\t'string': {\\n\\t\\tpattern: /([\\\"'])(\\\\\\\\(?:\\\\r\\\\n|[\\\\s\\\\S])|(?!\\\\1)[^\\\\\\\\\\\\r\\\\n])*\\\\1/,\\n\\t\\tgreedy: true\\n\\t},\\n\\t'class-name': {\\n\\t\\tpattern: /((?:\\\\b(?:class|interface|extends|implements|trait|instanceof|new)\\\\s+)|(?:catch\\\\s+\\\\())[a-z0-9_\\\\.\\\\\\\\]+/i,\\n\\t\\tlookbehind: true,\\n\\t\\tinside: {\\n\\t\\t\\tpunctuation: /(\\\\.|\\\\\\\\)/\\n\\t\\t}\\n\\t},\\n\\t'keyword': /\\\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\\\b/,\\n\\t'boolean': /\\\\b(true|false)\\\\b/,\\n\\t'function': /[a-z0-9_]+(?=\\\\()/i,\\n\\t'number': /\\\\b-?(?:0x[\\\\da-f]+|\\\\d*\\\\.?\\\\d+(?:e[+-]?\\\\d+)?)\\\\b/i,\\n\\t'operator': /--?|\\\\+\\\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\\\|\\\\|?|\\\\?|\\\\*|\\\\/|~|\\\\^|%/,\\n\\t'punctuation': /[{}[\\\\];(),.:]/\\n};\\n\\n\\n/* **********************************************\\n     Begin prism-javascript.js\\n********************************************** */\\n\\nPrism.languages.javascript = Prism.languages.extend('clike', {\\n\\t'keyword': /\\\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\\\b/,\\n\\t'number': /\\\\b-?(0x[\\\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\\\d*\\\\.?\\\\d+([Ee][+-]?\\\\d+)?|NaN|Infinity)\\\\b/,\\n\\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\\n\\t'function': /[_$a-zA-Z\\\\xA0-\\\\uFFFF][_$a-zA-Z0-9\\\\xA0-\\\\uFFFF]*(?=\\\\()/i\\n});\\n\\nPrism.languages.insertBefore('javascript', 'keyword', {\\n\\t'regex': {\\n\\t\\tpattern: /(^|[^/])\\\\/(?!\\\\/)(\\\\[.+?]|\\\\\\\\.|[^/\\\\\\\\\\\\r\\\\n])+\\\\/[gimyu]{0,5}(?=\\\\s*($|[\\\\r\\\\n,.;})]))/,\\n\\t\\tlookbehind: true,\\n\\t\\tgreedy: true\\n\\t}\\n});\\n\\nPrism.languages.insertBefore('javascript', 'string', {\\n\\t'template-string': {\\n\\t\\tpattern: /`(?:\\\\\\\\\\\\\\\\|\\\\\\\\?[^\\\\\\\\])*?`/,\\n\\t\\tgreedy: true,\\n\\t\\tinside: {\\n\\t\\t\\t'interpolation': {\\n\\t\\t\\t\\tpattern: /\\\\$\\\\{[^}]+\\\\}/,\\n\\t\\t\\t\\tinside: {\\n\\t\\t\\t\\t\\t'interpolation-punctuation': {\\n\\t\\t\\t\\t\\t\\tpattern: /^\\\\$\\\\{|\\\\}$/,\\n\\t\\t\\t\\t\\t\\talias: 'punctuation'\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\trest: Prism.languages.javascript\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\t'string': /[\\\\s\\\\S]+/\\n\\t\\t}\\n\\t}\\n});\\n\\nif (Prism.languages.markup) {\\n\\tPrism.languages.insertBefore('markup', 'tag', {\\n\\t\\t'script': {\\n\\t\\t\\tpattern: /(<script[\\\\w\\\\W]*?>)[\\\\w\\\\W]*?(?=<\\\\/script>)/i,\\n\\t\\t\\tlookbehind: true,\\n\\t\\t\\tinside: Prism.languages.javascript,\\n\\t\\t\\talias: 'language-javascript'\\n\\t\\t}\\n\\t});\\n}\\n\\nPrism.languages.js = Prism.languages.javascript;\\n\\n/* **********************************************\\n     Begin prism-file-highlight.js\\n********************************************** */\\n\\n(function () {\\n\\tif (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tself.Prism.fileHighlight = function() {\\n\\n\\t\\tvar Extensions = {\\n\\t\\t\\t'js': 'javascript',\\n\\t\\t\\t'py': 'python',\\n\\t\\t\\t'rb': 'ruby',\\n\\t\\t\\t'ps1': 'powershell',\\n\\t\\t\\t'psm1': 'powershell',\\n\\t\\t\\t'sh': 'bash',\\n\\t\\t\\t'bat': 'batch',\\n\\t\\t\\t'h': 'c',\\n\\t\\t\\t'tex': 'latex'\\n\\t\\t};\\n\\n\\t\\tif(Array.prototype.forEach) { // Check to prevent error in IE8\\n\\t\\t\\tArray.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {\\n\\t\\t\\t\\tvar src = pre.getAttribute('data-src');\\n\\n\\t\\t\\t\\tvar language, parent = pre;\\n\\t\\t\\t\\tvar lang = /\\\\blang(?:uage)?-(?!\\\\*)(\\\\w+)\\\\b/i;\\n\\t\\t\\t\\twhile (parent && !lang.test(parent.className)) {\\n\\t\\t\\t\\t\\tparent = parent.parentNode;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (parent) {\\n\\t\\t\\t\\t\\tlanguage = (pre.className.match(lang) || [, ''])[1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!language) {\\n\\t\\t\\t\\t\\tvar extension = (src.match(/\\\\.(\\\\w+)$/) || [, ''])[1];\\n\\t\\t\\t\\t\\tlanguage = Extensions[extension] || extension;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar code = document.createElement('code');\\n\\t\\t\\t\\tcode.className = 'language-' + language;\\n\\n\\t\\t\\t\\tpre.textContent = '';\\n\\n\\t\\t\\t\\tcode.textContent = 'Loading…';\\n\\n\\t\\t\\t\\tpre.appendChild(code);\\n\\n\\t\\t\\t\\tvar xhr = new XMLHttpRequest();\\n\\n\\t\\t\\t\\txhr.open('GET', src, true);\\n\\n\\t\\t\\t\\txhr.onreadystatechange = function () {\\n\\t\\t\\t\\t\\tif (xhr.readyState == 4) {\\n\\n\\t\\t\\t\\t\\t\\tif (xhr.status < 400 && xhr.responseText) {\\n\\t\\t\\t\\t\\t\\t\\tcode.textContent = xhr.responseText;\\n\\n\\t\\t\\t\\t\\t\\t\\tPrism.highlightElement(code);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (xhr.status >= 400) {\\n\\t\\t\\t\\t\\t\\t\\tcode.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tcode.textContent = '✖ Error: File does not exist or is empty';\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\txhr.send(null);\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t};\\n\\n\\tdocument.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);\\n\\n})();\\n\"\n\n/***/ },\n\n/***/ 649:\n/***/ function(module, exports) {\n\nmodule.exports = \"// The programming goals of Split.js are to deliver readable, understandable and\\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\\n// and very few assumptions about the user's page layout.\\n//\\n// Make sure all browsers handle this JS library correctly with ES5.\\n// More information here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\\n'use strict';\\n\\n// A wrapper function that does a couple things:\\n//\\n// 1. Doesn't pollute the global namespace. This is important for a library.\\n// 2. Allows us to mount the library in different module systems, as well as\\n//    directly in the browser.\\n(function() {\\n\\n// Save the global `this` for use later. In this case, since the library only\\n// runs in the browser, it will refer to `window`. Also, figure out if we're in IE8\\n// or not. IE8 will still render correctly, but will be static instead of draggable.\\n//\\n// Save a couple long function names that are used frequently.\\n// This optimization saves around 400 bytes.\\nvar global = this\\n  , isIE8 = global.attachEvent && !global[addEventListener]\\n  , document = global.document\\n  , addEventListener = 'addEventListener'\\n  , removeEventListener = 'removeEventListener'\\n  , getBoundingClientRect = 'getBoundingClientRect'\\n\\n  // This library only needs two helper functions:\\n  //\\n  // The first determines which prefixes of CSS calc we need.\\n  // We only need to do this once on startup, when this anonymous function is called.\\n  // \\n  // Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\\n  // http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\\n  , calc = (function () {\\n        var el\\n          , prefixes = [\\\"\\\", \\\"-webkit-\\\", \\\"-moz-\\\", \\\"-o-\\\"]\\n\\n        for (var i = 0; i < prefixes.length; i++) {\\n            el = document.createElement('div')\\n            el.style.cssText = \\\"width:\\\" + prefixes[i] + \\\"calc(9px)\\\"\\n\\n            if (el.style.length) {\\n                return prefixes[i] + \\\"calc\\\"\\n            }\\n        }\\n    })()\\n\\n  // The second helper function allows elements and string selectors to be used\\n  // interchangeably. In either case an element is returned. This allows us to\\n  // do `Split(elem1, elem2)` as well as `Split('#id1', '#id2')`.\\n  , elementOrSelector = function (el) {\\n        if (typeof el === 'string' || el instanceof String) {\\n            return document.querySelector(el)\\n        } else {\\n            return el\\n        }\\n    }\\n\\n  // The main function to initialize a split. Split.js thinks about each pair\\n  // of elements as an independant pair. Dragging the gutter between two elements\\n  // only changes the dimensions of elements in that pair. This is key to understanding\\n  // how the following functions operate, since each function is bound to a pair.\\n  // \\n  // A pair object is shaped like this:\\n  // \\n  // {\\n  //     a: DOM element,\\n  //     b: DOM element,\\n  //     aMin: Number,\\n  //     bMin: Number,\\n  //     dragging: Boolean,\\n  //     parent: DOM element,\\n  //     isFirst: Boolean,\\n  //     isLast: Boolean,\\n  //     direction: 'horizontal' | 'vertical'\\n  // }\\n  //\\n  // The basic sequence:\\n  // \\n  // 1. Set defaults to something sane. `options` doesn't have to be passed at all.\\n  // 2. Initialize a bunch of strings based on the direction we're splitting.\\n  //    A lot of the behavior in the rest of the library is paramatized down to\\n  //    rely on CSS strings and classes.\\n  // 3. Define the dragging helper functions, and a few helpers to go with them.\\n  // 4. Define a few more functions that \\\"balance\\\" the entire split instance.\\n  //    Split.js tries it's best to cope with min sizes that don't add up.\\n  // 5. Loop through the elements while pairing them off. Every pair gets an\\n  //    `pair` object, a gutter, and special isFirst/isLast properties.\\n  // 6. Actually size the pair elements, insert gutters and attach event listeners.\\n  // 7. Balance all of the pairs to accomodate min sizes as best as possible.\\n  , Split = function (ids, options) {\\n    var dimension\\n      , i\\n      , clientDimension\\n      , clientAxis\\n      , position\\n      , gutterClass\\n      , paddingA\\n      , paddingB\\n      , pairs = []\\n\\n    // 1. Set defaults to something sane. `options` doesn't have to be passed at all,\\n    // so create an options object if none exists. Pixel values 10, 100 and 30 are\\n    // arbitrary but feel natural.\\n    options = typeof options !== 'undefined' ?  options : {}\\n\\n    if (typeof options.gutterSize === 'undefined') options.gutterSize = 10\\n    if (typeof options.minSize === 'undefined') options.minSize = 100\\n    if (typeof options.snapOffset === 'undefined') options.snapOffset = 30\\n    if (typeof options.direction === 'undefined') options.direction = 'horizontal'\\n\\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\\n    // A lot of the behavior in the rest of the library is paramatized down to\\n    // rely on CSS strings and classes.\\n    if (options.direction == 'horizontal') {\\n        dimension = 'width'\\n        clientDimension = 'clientWidth'\\n        clientAxis = 'clientX'\\n        position = 'left'\\n        gutterClass = 'gutter gutter-horizontal'\\n        paddingA = 'paddingLeft'\\n        paddingB = 'paddingRight'\\n        if (!options.cursor) options.cursor = 'ew-resize'\\n    } else if (options.direction == 'vertical') {\\n        dimension = 'height'\\n        clientDimension = 'clientHeight'\\n        clientAxis = 'clientY'\\n        position = 'top'\\n        gutterClass = 'gutter gutter-vertical'\\n        paddingA = 'paddingTop'\\n        paddingB = 'paddingBottom'\\n        if (!options.cursor) options.cursor = 'ns-resize'\\n    }\\n\\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\\n    // Each helper is bound to a pair object that contains it's metadata. This\\n    // also makes it easy to store references to listeners that that will be\\n    // added and removed.\\n    // \\n    // Even though there are no other functions contained in them, aliasing\\n    // this to self saves 50 bytes or so since it's used so frequently.\\n    //\\n    // The pair object saves metadata like dragging state, position and\\n    // event listener references.\\n    //\\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\\n    // It also adds event listeners for mouse/touch events,\\n    // and prevents selection while dragging so avoid the selecting text.\\n    var startDragging = function (e) {\\n            // Alias frequently used variables to save space. 200 bytes.\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            // Call the onDragStart callback.\\n            if (!self.dragging && options.onDragStart) {\\n                options.onDragStart()\\n            }\\n\\n            // Don't actually drag the element. We emulate that in the drag function.\\n            e.preventDefault()\\n\\n            // Set the dragging property of the pair object.\\n            self.dragging = true\\n\\n            // Create two event listeners bound to the same pair object and store\\n            // them in the pair object.\\n            self.move = drag.bind(self)\\n            self.stop = stopDragging.bind(self)\\n\\n            // All the binding. `window` gets the stop events in case we drag out of the elements.\\n            global[addEventListener]('mouseup', self.stop)\\n            global[addEventListener]('touchend', self.stop)\\n            global[addEventListener]('touchcancel', self.stop)\\n\\n            self.parent[addEventListener]('mousemove', self.move)\\n            self.parent[addEventListener]('touchmove', self.move)\\n\\n            // Disable selection. Disable!\\n            a[addEventListener]('selectstart', noop)\\n            a[addEventListener]('dragstart', noop)\\n            b[addEventListener]('selectstart', noop)\\n            b[addEventListener]('dragstart', noop)\\n\\n            a.style.userSelect = 'none'\\n            a.style.webkitUserSelect = 'none'\\n            a.style.MozUserSelect = 'none'\\n            a.style.pointerEvents = 'none'\\n\\n            b.style.userSelect = 'none'\\n            b.style.webkitUserSelect = 'none'\\n            b.style.MozUserSelect = 'none'\\n            b.style.pointerEvents = 'none'\\n\\n            // Set the cursor, both on the gutter and the parent element.\\n            // Doing only a, b and gutter causes flickering.\\n            self.gutter.style.cursor = options.cursor\\n            self.parent.style.cursor = options.cursor\\n\\n            // Cache the initial sizes of the pair.\\n            calculateSizes.call(self)\\n        }\\n\\n      // stopDragging is very similar to startDragging in reverse.\\n      , stopDragging = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (self.dragging && options.onDragEnd) {\\n                options.onDragEnd()\\n            }\\n\\n            self.dragging = false\\n\\n            // Remove the stored event listeners. This is why we store them.\\n            global[removeEventListener]('mouseup', self.stop)\\n            global[removeEventListener]('touchend', self.stop)\\n            global[removeEventListener]('touchcancel', self.stop)\\n\\n            self.parent[removeEventListener]('mousemove', self.move)\\n            self.parent[removeEventListener]('touchmove', self.move)\\n\\n            // Delete them once they are removed. I think this makes a difference\\n            // in memory usage with a lot of splits on one page. But I don't know for sure.\\n            delete self.stop\\n            delete self.move\\n\\n            a[removeEventListener]('selectstart', noop)\\n            a[removeEventListener]('dragstart', noop)\\n            b[removeEventListener]('selectstart', noop)\\n            b[removeEventListener]('dragstart', noop)\\n\\n            a.style.userSelect = ''\\n            a.style.webkitUserSelect = ''\\n            a.style.MozUserSelect = ''\\n            a.style.pointerEvents = ''\\n\\n            b.style.userSelect = ''\\n            b.style.webkitUserSelect = ''\\n            b.style.MozUserSelect = ''\\n            b.style.pointerEvents = ''\\n\\n            self.gutter.style.cursor = ''\\n            self.parent.style.cursor = ''\\n        }\\n\\n      // drag, where all the magic happens. The logic is really quite simple:\\n      // \\n      // 1. Ignore if the pair is not dragging.\\n      // 2. Get the offset of the event.\\n      // 3. Snap offset to min if within snappable range (within min + snapOffset).\\n      // 4. Actually adjust each element in the pair to offset.\\n      // \\n      // ---------------------------------------------------------------------\\n      // |    | <- this.aMin               ||              this.bMin -> |    |\\n      // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\\n      // |    |  |                         ||                        |  |    |\\n      // |    |  |                         ||                        |  |    |\\n      // ---------------------------------------------------------------------\\n      // | <- this.start                                        this.size -> |\\n      , drag = function (e) {\\n            var offset\\n\\n            if (!this.dragging) return\\n\\n            // Get the offset of the event from the first side of the\\n            // pair `this.start`. Supports touch events, but not multitouch, so only the first\\n            // finger `touches[0]` is counted.\\n            if ('touches' in e) {\\n                offset = e.touches[0][clientAxis] - this.start\\n            } else {\\n                offset = e[clientAxis] - this.start\\n            }\\n\\n            // If within snapOffset of min or max, set offset to min or max.\\n            // snapOffset buffers aMin and bMin, so logic is opposite for both.\\n            // Include the appropriate gutter sizes to prevent overflows.\\n            if (offset <= this.aMin + options.snapOffset + this.aGutterSize) {\\n                offset = this.aMin + this.aGutterSize\\n            } else if (offset >= this.size - (this.bMin + options.snapOffset + this.bGutterSize)) {\\n                offset = this.size - (this.bMin + this.bGutterSize)\\n            }\\n\\n            // Actually adjust the size.\\n            adjust.call(this, offset)\\n\\n            // Call the drag callback continously. Don't do anything too intensive\\n            // in this callback.\\n            if (options.onDrag) {\\n                options.onDrag()\\n            }\\n        }\\n\\n      // Cache some important sizes when drag starts, so we don't have to do that\\n      // continously:\\n      // \\n      // `size`: The total size of the pair. First element + second element + first gutter + second gutter.\\n      // `percentage`: The percentage between 0-100 that the pair occupies in the parent.\\n      // `start`: The leading side of the first element.\\n      //\\n      // ------------------------------------------------ - - - - - - - - - - -\\n      // |      aGutterSize -> |||                      |                     |\\n      // |                     |||                      |                     |\\n      // |                     |||                      |                     |\\n      // |                     ||| <- bGutterSize       |                     |\\n      // ------------------------------------------------ - - - - - - - - - - -\\n      // | <- start                             size -> |       parentSize -> |\\n      , calculateSizes = function () {\\n            // Figure out the parent size minus padding.\\n            var computedStyle = global.getComputedStyle(this.parent)\\n              , parentSize = this.parent[clientDimension] - parseFloat(computedStyle[paddingA]) - parseFloat(computedStyle[paddingB])\\n\\n            this.size = this.a[getBoundingClientRect]()[dimension] + this.b[getBoundingClientRect]()[dimension] + this.aGutterSize + this.bGutterSize\\n            this.percentage = Math.min(this.size / parentSize * 100, 100)\\n            this.start = this.a[getBoundingClientRect]()[position]\\n        }\\n\\n      // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\\n      // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\\n      // which allows the viewport to be resized without additional logic.\\n      // Element a's size is the same as offset. b's size is total size - a size.\\n      // Both sizes are calculated from the initial parent percentage, then the gutter size is subtracted.\\n      , adjust = function (offset) {\\n            this.a.style[dimension] = calc + '(' + (offset / this.size * this.percentage) + '% - ' + this.aGutterSize + 'px)'\\n            this.b.style[dimension] = calc + '(' + (this.percentage - (offset / this.size * this.percentage)) + '% - ' + this.bGutterSize + 'px)'\\n        }\\n\\n      // 4. Define a few more functions that \\\"balance\\\" the entire split instance.\\n      // Split.js tries it's best to cope with min sizes that don't add up.\\n      // At some point this should go away since it breaks out of the calc(% - px) model.\\n      // Maybe it's a user error if you pass uncomputable minSizes.\\n      , fitMin = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (a[getBoundingClientRect]()[dimension] < self.aMin) {\\n                a.style[dimension] = (self.aMin - self.aGutterSize) + 'px'\\n                b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px'\\n            } else if (b[getBoundingClientRect]()[dimension] < self.bMin) {\\n                a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px'\\n                b.style[dimension] = (self.bMin - self.bGutterSize) + 'px'\\n            }\\n        }\\n      , fitMinReverse = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (b[getBoundingClientRect]()[dimension] < self.bMin) {\\n                a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px'\\n                b.style[dimension] = (self.bMin - self.bGutterSize) + 'px'\\n            } else if (a[getBoundingClientRect]()[dimension] < self.aMin) {\\n                a.style[dimension] = (self.aMin - self.aGutterSize) + 'px'\\n                b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px'\\n            }\\n        }\\n      , balancePairs = function (pairs) {\\n            for (var i = 0; i < pairs.length; i++) {\\n                calculateSizes.call(pairs[i])\\n                fitMin.call(pairs[i])\\n            }\\n\\n            for (i = pairs.length - 1; i >= 0; i--) {\\n                calculateSizes.call(pairs[i])\\n                fitMinReverse.call(pairs[i])\\n            }\\n        }\\n      , setElementSize = function (el, size, gutterSize) {\\n            // Split.js allows setting sizes via numbers (ideally), or if you must,\\n            // by string, like '300px'. This is less than ideal, because it breaks\\n            // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\\n            // make sure you calculate the gutter size by hand.\\n            if (typeof size !== 'string' && !(size instanceof String)) {\\n                if (!isIE8) {\\n                    size = calc + '(' + size + '% - ' + gutterSize + 'px)'\\n                } else {\\n                    size = options.sizes[i] + '%'\\n                }\\n            }\\n\\n            el.style[dimension] = size\\n        }\\n\\n      // No-op function to prevent default. Used to prevent selection.\\n      , noop = function () { return false }\\n\\n      // All DOM elements in the split should have a common parent. We can grab\\n      // the first elements parent and hope users read the docs because the\\n      // behavior will be whacky otherwise.\\n      , parent = elementOrSelector(ids[0]).parentNode\\n\\n    // Set default options.sizes to equal percentages of the parent element.\\n    if (!options.sizes) {\\n        var percent = 100 / ids.length\\n\\n        options.sizes = []\\n\\n        for (i = 0; i < ids.length; i++) {\\n            options.sizes.push(percent)\\n        }\\n    }\\n\\n    // Standardize minSize to an array if it isn't already. This allows minSize\\n    // to be passed as a number.\\n    if (!Array.isArray(options.minSize)) {\\n        var minSizes = []\\n\\n        for (i = 0; i < ids.length; i++) {\\n            minSizes.push(options.minSize)\\n        }\\n\\n        options.minSize = minSizes\\n    }\\n\\n    // 5. Loop through the elements while pairing them off. Every pair gets a\\n    // `pair` object, a gutter, and isFirst/isLast properties.\\n    //\\n    // Basic logic:\\n    //\\n    // - Starting with the second element `i > 0`, create `pair` objects with\\n    //   `a = ids[i - 1]` and `b = ids[i]`\\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\\n    // - Create gutter elements and add event listeners.\\n    // - Set the size of the elements, minus the gutter sizes.\\n    //\\n    // -----------------------------------------------------------------------\\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\\n    // |             |       isFirst       |                  |     isLast   |\\n    // |           pair 0                pair 1             pair 2           |\\n    // |             |                     |                  |              |\\n    // -----------------------------------------------------------------------\\n    for (i = 0; i < ids.length; i++) {\\n        var el = elementOrSelector(ids[i])\\n          , isFirstPair = (i == 1)\\n          , isLastPair = (i == ids.length - 1)\\n          , size = options.sizes[i]\\n          , gutterSize = options.gutterSize\\n          , pair\\n\\n        if (i > 0) {\\n            // Create the pair object with it's metadata.\\n            pair = {\\n                a: elementOrSelector(ids[i - 1]),\\n                b: el,\\n                aMin: options.minSize[i - 1],\\n                bMin: options.minSize[i],\\n                dragging: false,\\n                parent: parent,\\n                isFirst: isFirstPair,\\n                isLast: isLastPair,\\n                direction: options.direction\\n            }\\n\\n            // For first and last pairs, first and last gutter width is half.\\n            pair.aGutterSize = options.gutterSize\\n            pair.bGutterSize = options.gutterSize\\n\\n            if (isFirstPair) {\\n                pair.aGutterSize = options.gutterSize / 2\\n            }\\n\\n            if (isLastPair) {\\n                pair.bGutterSize = options.gutterSize / 2\\n            }\\n        }\\n\\n        // Determine the size of the current element. IE8 is supported by\\n        // staticly assigning sizes without draggable gutters. Assigns a string\\n        // to `size`.\\n        // \\n        // IE9 and above\\n        if (!isIE8) {\\n            // Create gutter elements for each pair.\\n            if (i > 0) {\\n                var gutter = document.createElement('div')\\n\\n                gutter.className = gutterClass\\n                gutter.style[dimension] = options.gutterSize + 'px'\\n\\n                gutter[addEventListener]('mousedown', startDragging.bind(pair))\\n                gutter[addEventListener]('touchstart', startDragging.bind(pair))\\n\\n                parent.insertBefore(gutter, el)\\n\\n                pair.gutter = gutter\\n            }\\n\\n            // Half-size gutters for first and last elements.\\n            if (i === 0 || i == ids.length - 1) {\\n                gutterSize = options.gutterSize / 2\\n            }\\n        }\\n\\n        // Set the element size to our determined size.\\n        setElementSize(el, size, gutterSize)\\n\\n        // After the first iteration, and we have a pair object, append it to the\\n        // list of pairs.\\n        if (i > 0) {\\n            pairs.push(pair)\\n        }\\n    }\\n\\n    // Balance the pairs to try to accomodate min sizes.\\n    balancePairs(pairs)\\n\\n    return {\\n        setSizes: function (sizes) {\\n            for (var i = 0; i < sizes.length; i++) {\\n                if (i > 0) {\\n                    var pair = pairs[i - 1]\\n\\n                    setElementSize(pair.a, sizes[i - 1], pair.aGutterSize)\\n                    setElementSize(pair.b, sizes[i], pair.bGutterSize)\\n                }\\n            }\\n        },\\n        collapse: function (i) {\\n            var pair\\n\\n            if (i === pairs.length) {\\n                pair = pairs[i - 1]\\n\\n                calculateSizes.call(pair)\\n                adjust.call(pair, pair.size - pair.bGutterSize)\\n            } else {\\n                pair = pairs[i]\\n\\n                calculateSizes.call(pair)\\n                adjust.call(pair, pair.aGutterSize)\\n            }\\n        },\\n        destroy: function () {\\n            for (var i = 0; i < pairs.length; i++) {\\n                pairs[i].parent.removeChild(pairs[i].gutter)\\n                pairs[i].a.style[dimension] = ''\\n                pairs[i].b.style[dimension] = ''\\n            }\\n        }\\n    }\\n}\\n\\n// Play nicely with module systems, and the browser too if you include it raw.\\nif (typeof exports !== 'undefined') {\\n    if (typeof module !== 'undefined' && module.exports) {\\n        exports = module.exports = Split\\n    }\\n    exports.Split = Split\\n} else {\\n    global.Split = Split\\n}\\n\\n// Call our wrapper function with the current global. In this case, `window`.\\n}).call(window);\\n\"\n\n/***/ },\n\n/***/ 677:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(375);\nmodule.exports = __webpack_require__(374);\n\n\n/***/ }\n\n},[677]);\n\n\n// WEBPACK FOOTER //\n// scripts.1a98e92f27987b318cfc.bundle.js","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/adebisi/Public/ng2-split/~/script-loader/addScript.js\n// module id = 371\n// module chunks = 2","require(\"!!/home/adebisi/Public/ng2-split/node_modules/script-loader/addScript.js\")(require(\"!!/home/adebisi/Public/ng2-split/node_modules/raw-loader/index.js!/home/adebisi/Public/ng2-split/node_modules/prismjs/prism.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/adebisi/Public/ng2-split/~/prismjs/prism.js\n// module id = 374\n// module chunks = 2","require(\"!!/home/adebisi/Public/ng2-split/node_modules/script-loader/addScript.js\")(require(\"!!/home/adebisi/Public/ng2-split/node_modules/raw-loader/index.js!/home/adebisi/Public/ng2-split/node_modules/split.js/split.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/adebisi/Public/ng2-split/~/split.js/split.js\n// module id = 375\n// module chunks = 2","module.exports = \"\\n/* **********************************************\\n     Begin prism-core.js\\n********************************************** */\\n\\nvar _self = (typeof window !== 'undefined')\\n\\t? window   // if in browser\\n\\t: (\\n\\t\\t(typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope)\\n\\t\\t? self // if in worker\\n\\t\\t: {}   // if in node js\\n\\t);\\n\\n/**\\n * Prism: Lightweight, robust, elegant syntax highlighting\\n * MIT license http://www.opensource.org/licenses/mit-license.php/\\n * @author Lea Verou http://lea.verou.me\\n */\\n\\nvar Prism = (function(){\\n\\n// Private helper vars\\nvar lang = /\\\\blang(?:uage)?-(\\\\w+)\\\\b/i;\\nvar uniqueId = 0;\\n\\nvar _ = _self.Prism = {\\n\\tutil: {\\n\\t\\tencode: function (tokens) {\\n\\t\\t\\tif (tokens instanceof Token) {\\n\\t\\t\\t\\treturn new Token(tokens.type, _.util.encode(tokens.content), tokens.alias);\\n\\t\\t\\t} else if (_.util.type(tokens) === 'Array') {\\n\\t\\t\\t\\treturn tokens.map(_.util.encode);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\treturn tokens.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\\\\u00a0/g, ' ');\\n\\t\\t\\t}\\n\\t\\t},\\n\\n\\t\\ttype: function (o) {\\n\\t\\t\\treturn Object.prototype.toString.call(o).match(/\\\\[object (\\\\w+)\\\\]/)[1];\\n\\t\\t},\\n\\n\\t\\tobjId: function (obj) {\\n\\t\\t\\tif (!obj['__id']) {\\n\\t\\t\\t\\tObject.defineProperty(obj, '__id', { value: ++uniqueId });\\n\\t\\t\\t}\\n\\t\\t\\treturn obj['__id'];\\n\\t\\t},\\n\\n\\t\\t// Deep clone a language definition (e.g. to extend it)\\n\\t\\tclone: function (o) {\\n\\t\\t\\tvar type = _.util.type(o);\\n\\n\\t\\t\\tswitch (type) {\\n\\t\\t\\t\\tcase 'Object':\\n\\t\\t\\t\\t\\tvar clone = {};\\n\\n\\t\\t\\t\\t\\tfor (var key in o) {\\n\\t\\t\\t\\t\\t\\tif (o.hasOwnProperty(key)) {\\n\\t\\t\\t\\t\\t\\t\\tclone[key] = _.util.clone(o[key]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\treturn clone;\\n\\n\\t\\t\\t\\tcase 'Array':\\n\\t\\t\\t\\t\\t// Check for existence for IE8\\n\\t\\t\\t\\t\\treturn o.map && o.map(function(v) { return _.util.clone(v); });\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn o;\\n\\t\\t}\\n\\t},\\n\\n\\tlanguages: {\\n\\t\\textend: function (id, redef) {\\n\\t\\t\\tvar lang = _.util.clone(_.languages[id]);\\n\\n\\t\\t\\tfor (var key in redef) {\\n\\t\\t\\t\\tlang[key] = redef[key];\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn lang;\\n\\t\\t},\\n\\n\\t\\t/**\\n\\t\\t * Insert a token before another token in a language literal\\n\\t\\t * As this needs to recreate the object (we cannot actually insert before keys in object literals),\\n\\t\\t * we cannot just provide an object, we need anobject and a key.\\n\\t\\t * @param inside The key (or language id) of the parent\\n\\t\\t * @param before The key to insert before. If not provided, the function appends instead.\\n\\t\\t * @param insert Object with the key/value pairs to insert\\n\\t\\t * @param root The object that contains `inside`. If equal to Prism.languages, it can be omitted.\\n\\t\\t */\\n\\t\\tinsertBefore: function (inside, before, insert, root) {\\n\\t\\t\\troot = root || _.languages;\\n\\t\\t\\tvar grammar = root[inside];\\n\\n\\t\\t\\tif (arguments.length == 2) {\\n\\t\\t\\t\\tinsert = arguments[1];\\n\\n\\t\\t\\t\\tfor (var newToken in insert) {\\n\\t\\t\\t\\t\\tif (insert.hasOwnProperty(newToken)) {\\n\\t\\t\\t\\t\\t\\tgrammar[newToken] = insert[newToken];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn grammar;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar ret = {};\\n\\n\\t\\t\\tfor (var token in grammar) {\\n\\n\\t\\t\\t\\tif (grammar.hasOwnProperty(token)) {\\n\\n\\t\\t\\t\\t\\tif (token == before) {\\n\\n\\t\\t\\t\\t\\t\\tfor (var newToken in insert) {\\n\\n\\t\\t\\t\\t\\t\\t\\tif (insert.hasOwnProperty(newToken)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tret[newToken] = insert[newToken];\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tret[token] = grammar[token];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// Update references in other language definitions\\n\\t\\t\\t_.languages.DFS(_.languages, function(key, value) {\\n\\t\\t\\t\\tif (value === root[inside] && key != inside) {\\n\\t\\t\\t\\t\\tthis[key] = ret;\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\n\\t\\t\\treturn root[inside] = ret;\\n\\t\\t},\\n\\n\\t\\t// Traverse a language definition with Depth First Search\\n\\t\\tDFS: function(o, callback, type, visited) {\\n\\t\\t\\tvisited = visited || {};\\n\\t\\t\\tfor (var i in o) {\\n\\t\\t\\t\\tif (o.hasOwnProperty(i)) {\\n\\t\\t\\t\\t\\tcallback.call(o, i, o[i], type || i);\\n\\n\\t\\t\\t\\t\\tif (_.util.type(o[i]) === 'Object' && !visited[_.util.objId(o[i])]) {\\n\\t\\t\\t\\t\\t\\tvisited[_.util.objId(o[i])] = true;\\n\\t\\t\\t\\t\\t\\t_.languages.DFS(o[i], callback, null, visited);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if (_.util.type(o[i]) === 'Array' && !visited[_.util.objId(o[i])]) {\\n\\t\\t\\t\\t\\t\\tvisited[_.util.objId(o[i])] = true;\\n\\t\\t\\t\\t\\t\\t_.languages.DFS(o[i], callback, i, visited);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t},\\n\\tplugins: {},\\n\\n\\thighlightAll: function(async, callback) {\\n\\t\\tvar env = {\\n\\t\\t\\tcallback: callback,\\n\\t\\t\\tselector: 'code[class*=\\\"language-\\\"], [class*=\\\"language-\\\"] code, code[class*=\\\"lang-\\\"], [class*=\\\"lang-\\\"] code'\\n\\t\\t};\\n\\n\\t\\t_.hooks.run(\\\"before-highlightall\\\", env);\\n\\n\\t\\tvar elements = env.elements || document.querySelectorAll(env.selector);\\n\\n\\t\\tfor (var i=0, element; element = elements[i++];) {\\n\\t\\t\\t_.highlightElement(element, async === true, env.callback);\\n\\t\\t}\\n\\t},\\n\\n\\thighlightElement: function(element, async, callback) {\\n\\t\\t// Find language\\n\\t\\tvar language, grammar, parent = element;\\n\\n\\t\\twhile (parent && !lang.test(parent.className)) {\\n\\t\\t\\tparent = parent.parentNode;\\n\\t\\t}\\n\\n\\t\\tif (parent) {\\n\\t\\t\\tlanguage = (parent.className.match(lang) || [,''])[1].toLowerCase();\\n\\t\\t\\tgrammar = _.languages[language];\\n\\t\\t}\\n\\n\\t\\t// Set language on the element, if not present\\n\\t\\telement.className = element.className.replace(lang, '').replace(/\\\\s+/g, ' ') + ' language-' + language;\\n\\n\\t\\t// Set language on the parent, for styling\\n\\t\\tparent = element.parentNode;\\n\\n\\t\\tif (/pre/i.test(parent.nodeName)) {\\n\\t\\t\\tparent.className = parent.className.replace(lang, '').replace(/\\\\s+/g, ' ') + ' language-' + language;\\n\\t\\t}\\n\\n\\t\\tvar code = element.textContent;\\n\\n\\t\\tvar env = {\\n\\t\\t\\telement: element,\\n\\t\\t\\tlanguage: language,\\n\\t\\t\\tgrammar: grammar,\\n\\t\\t\\tcode: code\\n\\t\\t};\\n\\n\\t\\t_.hooks.run('before-sanity-check', env);\\n\\n\\t\\tif (!env.code || !env.grammar) {\\n\\t\\t\\t_.hooks.run('complete', env);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\t_.hooks.run('before-highlight', env);\\n\\n\\t\\tif (async && _self.Worker) {\\n\\t\\t\\tvar worker = new Worker(_.filename);\\n\\n\\t\\t\\tworker.onmessage = function(evt) {\\n\\t\\t\\t\\tenv.highlightedCode = evt.data;\\n\\n\\t\\t\\t\\t_.hooks.run('before-insert', env);\\n\\n\\t\\t\\t\\tenv.element.innerHTML = env.highlightedCode;\\n\\n\\t\\t\\t\\tcallback && callback.call(env.element);\\n\\t\\t\\t\\t_.hooks.run('after-highlight', env);\\n\\t\\t\\t\\t_.hooks.run('complete', env);\\n\\t\\t\\t};\\n\\n\\t\\t\\tworker.postMessage(JSON.stringify({\\n\\t\\t\\t\\tlanguage: env.language,\\n\\t\\t\\t\\tcode: env.code,\\n\\t\\t\\t\\timmediateClose: true\\n\\t\\t\\t}));\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tenv.highlightedCode = _.highlight(env.code, env.grammar, env.language);\\n\\n\\t\\t\\t_.hooks.run('before-insert', env);\\n\\n\\t\\t\\tenv.element.innerHTML = env.highlightedCode;\\n\\n\\t\\t\\tcallback && callback.call(element);\\n\\n\\t\\t\\t_.hooks.run('after-highlight', env);\\n\\t\\t\\t_.hooks.run('complete', env);\\n\\t\\t}\\n\\t},\\n\\n\\thighlight: function (text, grammar, language) {\\n\\t\\tvar tokens = _.tokenize(text, grammar);\\n\\t\\treturn Token.stringify(_.util.encode(tokens), language);\\n\\t},\\n\\n\\ttokenize: function(text, grammar, language) {\\n\\t\\tvar Token = _.Token;\\n\\n\\t\\tvar strarr = [text];\\n\\n\\t\\tvar rest = grammar.rest;\\n\\n\\t\\tif (rest) {\\n\\t\\t\\tfor (var token in rest) {\\n\\t\\t\\t\\tgrammar[token] = rest[token];\\n\\t\\t\\t}\\n\\n\\t\\t\\tdelete grammar.rest;\\n\\t\\t}\\n\\n\\t\\ttokenloop: for (var token in grammar) {\\n\\t\\t\\tif(!grammar.hasOwnProperty(token) || !grammar[token]) {\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\n\\t\\t\\tvar patterns = grammar[token];\\n\\t\\t\\tpatterns = (_.util.type(patterns) === \\\"Array\\\") ? patterns : [patterns];\\n\\n\\t\\t\\tfor (var j = 0; j < patterns.length; ++j) {\\n\\t\\t\\t\\tvar pattern = patterns[j],\\n\\t\\t\\t\\t\\tinside = pattern.inside,\\n\\t\\t\\t\\t\\tlookbehind = !!pattern.lookbehind,\\n\\t\\t\\t\\t\\tgreedy = !!pattern.greedy,\\n\\t\\t\\t\\t\\tlookbehindLength = 0,\\n\\t\\t\\t\\t\\talias = pattern.alias;\\n\\n\\t\\t\\t\\tpattern = pattern.pattern || pattern;\\n\\n\\t\\t\\t\\tfor (var i=0; i<strarr.length; i++) { // Don’t cache length as it changes during the loop\\n\\n\\t\\t\\t\\t\\tvar str = strarr[i];\\n\\n\\t\\t\\t\\t\\tif (strarr.length > text.length) {\\n\\t\\t\\t\\t\\t\\t// Something went terribly wrong, ABORT, ABORT!\\n\\t\\t\\t\\t\\t\\tbreak tokenloop;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (str instanceof Token) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tpattern.lastIndex = 0;\\n\\n\\t\\t\\t\\t\\tvar match = pattern.exec(str),\\n\\t\\t\\t\\t\\t    delNum = 1;\\n\\n\\t\\t\\t\\t\\t// Greedy patterns can override/remove up to two previously matched tokens\\n\\t\\t\\t\\t\\tif (!match && greedy && i != strarr.length - 1) {\\n\\t\\t\\t\\t\\t\\t// Reconstruct the original text using the next two tokens\\n\\t\\t\\t\\t\\t\\tvar nextToken = strarr[i + 1].matchedStr || strarr[i + 1],\\n\\t\\t\\t\\t\\t\\t    combStr = str + nextToken;\\n\\n\\t\\t\\t\\t\\t\\tif (i < strarr.length - 2) {\\n\\t\\t\\t\\t\\t\\t\\tcombStr += strarr[i + 2].matchedStr || strarr[i + 2];\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// Try the pattern again on the reconstructed text\\n\\t\\t\\t\\t\\t\\tpattern.lastIndex = 0;\\n\\t\\t\\t\\t\\t\\tmatch = pattern.exec(combStr);\\n\\t\\t\\t\\t\\t\\tif (!match) {\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\tvar from = match.index + (lookbehind ? match[1].length : 0);\\n\\t\\t\\t\\t\\t\\t// To be a valid candidate, the new match has to start inside of str\\n\\t\\t\\t\\t\\t\\tif (from >= str.length) {\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tvar to = match.index + match[0].length,\\n\\t\\t\\t\\t\\t\\t    len = str.length + nextToken.length;\\n\\n\\t\\t\\t\\t\\t\\t// Number of tokens to delete and replace with the new match\\n\\t\\t\\t\\t\\t\\tdelNum = 3;\\n\\n\\t\\t\\t\\t\\t\\tif (to <= len) {\\n\\t\\t\\t\\t\\t\\t\\tif (strarr[i + 1].greedy) {\\n\\t\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tdelNum = 2;\\n\\t\\t\\t\\t\\t\\t\\tcombStr = combStr.slice(0, len);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstr = combStr;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif (!match) {\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif(lookbehind) {\\n\\t\\t\\t\\t\\t\\tlookbehindLength = match[1].length;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar from = match.index + lookbehindLength,\\n\\t\\t\\t\\t\\t    match = match[0].slice(lookbehindLength),\\n\\t\\t\\t\\t\\t    to = from + match.length,\\n\\t\\t\\t\\t\\t    before = str.slice(0, from),\\n\\t\\t\\t\\t\\t    after = str.slice(to);\\n\\n\\t\\t\\t\\t\\tvar args = [i, delNum];\\n\\n\\t\\t\\t\\t\\tif (before) {\\n\\t\\t\\t\\t\\t\\targs.push(before);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tvar wrapped = new Token(token, inside? _.tokenize(match, inside) : match, alias, match, greedy);\\n\\n\\t\\t\\t\\t\\targs.push(wrapped);\\n\\n\\t\\t\\t\\t\\tif (after) {\\n\\t\\t\\t\\t\\t\\targs.push(after);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tArray.prototype.splice.apply(strarr, args);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn strarr;\\n\\t},\\n\\n\\thooks: {\\n\\t\\tall: {},\\n\\n\\t\\tadd: function (name, callback) {\\n\\t\\t\\tvar hooks = _.hooks.all;\\n\\n\\t\\t\\thooks[name] = hooks[name] || [];\\n\\n\\t\\t\\thooks[name].push(callback);\\n\\t\\t},\\n\\n\\t\\trun: function (name, env) {\\n\\t\\t\\tvar callbacks = _.hooks.all[name];\\n\\n\\t\\t\\tif (!callbacks || !callbacks.length) {\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor (var i=0, callback; callback = callbacks[i++];) {\\n\\t\\t\\t\\tcallback(env);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n};\\n\\nvar Token = _.Token = function(type, content, alias, matchedStr, greedy) {\\n\\tthis.type = type;\\n\\tthis.content = content;\\n\\tthis.alias = alias;\\n\\t// Copy of the full string this token was created from\\n\\tthis.matchedStr = matchedStr || null;\\n\\tthis.greedy = !!greedy;\\n};\\n\\nToken.stringify = function(o, language, parent) {\\n\\tif (typeof o == 'string') {\\n\\t\\treturn o;\\n\\t}\\n\\n\\tif (_.util.type(o) === 'Array') {\\n\\t\\treturn o.map(function(element) {\\n\\t\\t\\treturn Token.stringify(element, language, o);\\n\\t\\t}).join('');\\n\\t}\\n\\n\\tvar env = {\\n\\t\\ttype: o.type,\\n\\t\\tcontent: Token.stringify(o.content, language, parent),\\n\\t\\ttag: 'span',\\n\\t\\tclasses: ['token', o.type],\\n\\t\\tattributes: {},\\n\\t\\tlanguage: language,\\n\\t\\tparent: parent\\n\\t};\\n\\n\\tif (env.type == 'comment') {\\n\\t\\tenv.attributes['spellcheck'] = 'true';\\n\\t}\\n\\n\\tif (o.alias) {\\n\\t\\tvar aliases = _.util.type(o.alias) === 'Array' ? o.alias : [o.alias];\\n\\t\\tArray.prototype.push.apply(env.classes, aliases);\\n\\t}\\n\\n\\t_.hooks.run('wrap', env);\\n\\n\\tvar attributes = '';\\n\\n\\tfor (var name in env.attributes) {\\n\\t\\tattributes += (attributes ? ' ' : '') + name + '=\\\"' + (env.attributes[name] || '') + '\\\"';\\n\\t}\\n\\n\\treturn '<' + env.tag + ' class=\\\"' + env.classes.join(' ') + '\\\" ' + attributes + '>' + env.content + '</' + env.tag + '>';\\n\\n};\\n\\nif (!_self.document) {\\n\\tif (!_self.addEventListener) {\\n\\t\\t// in Node.js\\n\\t\\treturn _self.Prism;\\n\\t}\\n \\t// In worker\\n\\t_self.addEventListener('message', function(evt) {\\n\\t\\tvar message = JSON.parse(evt.data),\\n\\t\\t    lang = message.language,\\n\\t\\t    code = message.code,\\n\\t\\t    immediateClose = message.immediateClose;\\n\\n\\t\\t_self.postMessage(_.highlight(code, _.languages[lang], lang));\\n\\t\\tif (immediateClose) {\\n\\t\\t\\t_self.close();\\n\\t\\t}\\n\\t}, false);\\n\\n\\treturn _self.Prism;\\n}\\n\\n//Get current script and highlight\\nvar script = document.currentScript || [].slice.call(document.getElementsByTagName(\\\"script\\\")).pop();\\n\\nif (script) {\\n\\t_.filename = script.src;\\n\\n\\tif (document.addEventListener && !script.hasAttribute('data-manual')) {\\n\\t\\tif(document.readyState !== \\\"loading\\\") {\\n\\t\\t\\trequestAnimationFrame(_.highlightAll, 0);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdocument.addEventListener('DOMContentLoaded', _.highlightAll);\\n\\t\\t}\\n\\t}\\n}\\n\\nreturn _self.Prism;\\n\\n})();\\n\\nif (typeof module !== 'undefined' && module.exports) {\\n\\tmodule.exports = Prism;\\n}\\n\\n// hack for components to work correctly in node.js\\nif (typeof global !== 'undefined') {\\n\\tglobal.Prism = Prism;\\n}\\n\\n\\n/* **********************************************\\n     Begin prism-markup.js\\n********************************************** */\\n\\nPrism.languages.markup = {\\n\\t'comment': /<!--[\\\\w\\\\W]*?-->/,\\n\\t'prolog': /<\\\\?[\\\\w\\\\W]+?\\\\?>/,\\n\\t'doctype': /<!DOCTYPE[\\\\w\\\\W]+?>/,\\n\\t'cdata': /<!\\\\[CDATA\\\\[[\\\\w\\\\W]*?]]>/i,\\n\\t'tag': {\\n\\t\\tpattern: /<\\\\/?(?!\\\\d)[^\\\\s>\\\\/=.$<]+(?:\\\\s+[^\\\\s>\\\\/=]+(?:=(?:(\\\"|')(?:\\\\\\\\\\\\1|\\\\\\\\?(?!\\\\1)[\\\\w\\\\W])*\\\\1|[^\\\\s'\\\">=]+))?)*\\\\s*\\\\/?>/i,\\n\\t\\tinside: {\\n\\t\\t\\t'tag': {\\n\\t\\t\\t\\tpattern: /^<\\\\/?[^\\\\s>\\\\/]+/i,\\n\\t\\t\\t\\tinside: {\\n\\t\\t\\t\\t\\t'punctuation': /^<\\\\/?/,\\n\\t\\t\\t\\t\\t'namespace': /^[^\\\\s>\\\\/:]+:/\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\t'attr-value': {\\n\\t\\t\\t\\tpattern: /=(?:('|\\\")[\\\\w\\\\W]*?(\\\\1)|[^\\\\s>]+)/i,\\n\\t\\t\\t\\tinside: {\\n\\t\\t\\t\\t\\t'punctuation': /[=>\\\"']/\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\t'punctuation': /\\\\/?>/,\\n\\t\\t\\t'attr-name': {\\n\\t\\t\\t\\tpattern: /[^\\\\s>\\\\/]+/,\\n\\t\\t\\t\\tinside: {\\n\\t\\t\\t\\t\\t'namespace': /^[^\\\\s>\\\\/:]+:/\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t},\\n\\t'entity': /&#?[\\\\da-z]{1,8};/i\\n};\\n\\n// Plugin to make entity title show the real entity, idea by Roman Komarov\\nPrism.hooks.add('wrap', function(env) {\\n\\n\\tif (env.type === 'entity') {\\n\\t\\tenv.attributes['title'] = env.content.replace(/&amp;/, '&');\\n\\t}\\n});\\n\\nPrism.languages.xml = Prism.languages.markup;\\nPrism.languages.html = Prism.languages.markup;\\nPrism.languages.mathml = Prism.languages.markup;\\nPrism.languages.svg = Prism.languages.markup;\\n\\n\\n/* **********************************************\\n     Begin prism-css.js\\n********************************************** */\\n\\nPrism.languages.css = {\\n\\t'comment': /\\\\/\\\\*[\\\\w\\\\W]*?\\\\*\\\\//,\\n\\t'atrule': {\\n\\t\\tpattern: /@[\\\\w-]+?.*?(;|(?=\\\\s*\\\\{))/i,\\n\\t\\tinside: {\\n\\t\\t\\t'rule': /@[\\\\w-]+/\\n\\t\\t\\t// See rest below\\n\\t\\t}\\n\\t},\\n\\t'url': /url\\\\((?:([\\\"'])(\\\\\\\\(?:\\\\r\\\\n|[\\\\w\\\\W])|(?!\\\\1)[^\\\\\\\\\\\\r\\\\n])*\\\\1|.*?)\\\\)/i,\\n\\t'selector': /[^\\\\{\\\\}\\\\s][^\\\\{\\\\};]*?(?=\\\\s*\\\\{)/,\\n\\t'string': /(\\\"|')(\\\\\\\\(?:\\\\r\\\\n|[\\\\w\\\\W])|(?!\\\\1)[^\\\\\\\\\\\\r\\\\n])*\\\\1/,\\n\\t'property': /(\\\\b|\\\\B)[\\\\w-]+(?=\\\\s*:)/i,\\n\\t'important': /\\\\B!important\\\\b/i,\\n\\t'function': /[-a-z0-9]+(?=\\\\()/i,\\n\\t'punctuation': /[(){};:]/\\n};\\n\\nPrism.languages.css['atrule'].inside.rest = Prism.util.clone(Prism.languages.css);\\n\\nif (Prism.languages.markup) {\\n\\tPrism.languages.insertBefore('markup', 'tag', {\\n\\t\\t'style': {\\n\\t\\t\\tpattern: /(<style[\\\\w\\\\W]*?>)[\\\\w\\\\W]*?(?=<\\\\/style>)/i,\\n\\t\\t\\tlookbehind: true,\\n\\t\\t\\tinside: Prism.languages.css,\\n\\t\\t\\talias: 'language-css'\\n\\t\\t}\\n\\t});\\n\\t\\n\\tPrism.languages.insertBefore('inside', 'attr-value', {\\n\\t\\t'style-attr': {\\n\\t\\t\\tpattern: /\\\\s*style=(\\\"|').*?\\\\1/i,\\n\\t\\t\\tinside: {\\n\\t\\t\\t\\t'attr-name': {\\n\\t\\t\\t\\t\\tpattern: /^\\\\s*style/i,\\n\\t\\t\\t\\t\\tinside: Prism.languages.markup.tag.inside\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\t'punctuation': /^\\\\s*=\\\\s*['\\\"]|['\\\"]\\\\s*$/,\\n\\t\\t\\t\\t'attr-value': {\\n\\t\\t\\t\\t\\tpattern: /.+/i,\\n\\t\\t\\t\\t\\tinside: Prism.languages.css\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\talias: 'language-css'\\n\\t\\t}\\n\\t}, Prism.languages.markup.tag);\\n}\\n\\n/* **********************************************\\n     Begin prism-clike.js\\n********************************************** */\\n\\nPrism.languages.clike = {\\n\\t'comment': [\\n\\t\\t{\\n\\t\\t\\tpattern: /(^|[^\\\\\\\\])\\\\/\\\\*[\\\\w\\\\W]*?\\\\*\\\\//,\\n\\t\\t\\tlookbehind: true\\n\\t\\t},\\n\\t\\t{\\n\\t\\t\\tpattern: /(^|[^\\\\\\\\:])\\\\/\\\\/.*/,\\n\\t\\t\\tlookbehind: true\\n\\t\\t}\\n\\t],\\n\\t'string': {\\n\\t\\tpattern: /([\\\"'])(\\\\\\\\(?:\\\\r\\\\n|[\\\\s\\\\S])|(?!\\\\1)[^\\\\\\\\\\\\r\\\\n])*\\\\1/,\\n\\t\\tgreedy: true\\n\\t},\\n\\t'class-name': {\\n\\t\\tpattern: /((?:\\\\b(?:class|interface|extends|implements|trait|instanceof|new)\\\\s+)|(?:catch\\\\s+\\\\())[a-z0-9_\\\\.\\\\\\\\]+/i,\\n\\t\\tlookbehind: true,\\n\\t\\tinside: {\\n\\t\\t\\tpunctuation: /(\\\\.|\\\\\\\\)/\\n\\t\\t}\\n\\t},\\n\\t'keyword': /\\\\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\\\\b/,\\n\\t'boolean': /\\\\b(true|false)\\\\b/,\\n\\t'function': /[a-z0-9_]+(?=\\\\()/i,\\n\\t'number': /\\\\b-?(?:0x[\\\\da-f]+|\\\\d*\\\\.?\\\\d+(?:e[+-]?\\\\d+)?)\\\\b/i,\\n\\t'operator': /--?|\\\\+\\\\+?|!=?=?|<=?|>=?|==?=?|&&?|\\\\|\\\\|?|\\\\?|\\\\*|\\\\/|~|\\\\^|%/,\\n\\t'punctuation': /[{}[\\\\];(),.:]/\\n};\\n\\n\\n/* **********************************************\\n     Begin prism-javascript.js\\n********************************************** */\\n\\nPrism.languages.javascript = Prism.languages.extend('clike', {\\n\\t'keyword': /\\\\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\\\\b/,\\n\\t'number': /\\\\b-?(0x[\\\\dA-Fa-f]+|0b[01]+|0o[0-7]+|\\\\d*\\\\.?\\\\d+([Ee][+-]?\\\\d+)?|NaN|Infinity)\\\\b/,\\n\\t// Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)\\n\\t'function': /[_$a-zA-Z\\\\xA0-\\\\uFFFF][_$a-zA-Z0-9\\\\xA0-\\\\uFFFF]*(?=\\\\()/i\\n});\\n\\nPrism.languages.insertBefore('javascript', 'keyword', {\\n\\t'regex': {\\n\\t\\tpattern: /(^|[^/])\\\\/(?!\\\\/)(\\\\[.+?]|\\\\\\\\.|[^/\\\\\\\\\\\\r\\\\n])+\\\\/[gimyu]{0,5}(?=\\\\s*($|[\\\\r\\\\n,.;})]))/,\\n\\t\\tlookbehind: true,\\n\\t\\tgreedy: true\\n\\t}\\n});\\n\\nPrism.languages.insertBefore('javascript', 'string', {\\n\\t'template-string': {\\n\\t\\tpattern: /`(?:\\\\\\\\\\\\\\\\|\\\\\\\\?[^\\\\\\\\])*?`/,\\n\\t\\tgreedy: true,\\n\\t\\tinside: {\\n\\t\\t\\t'interpolation': {\\n\\t\\t\\t\\tpattern: /\\\\$\\\\{[^}]+\\\\}/,\\n\\t\\t\\t\\tinside: {\\n\\t\\t\\t\\t\\t'interpolation-punctuation': {\\n\\t\\t\\t\\t\\t\\tpattern: /^\\\\$\\\\{|\\\\}$/,\\n\\t\\t\\t\\t\\t\\talias: 'punctuation'\\n\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\trest: Prism.languages.javascript\\n\\t\\t\\t\\t}\\n\\t\\t\\t},\\n\\t\\t\\t'string': /[\\\\s\\\\S]+/\\n\\t\\t}\\n\\t}\\n});\\n\\nif (Prism.languages.markup) {\\n\\tPrism.languages.insertBefore('markup', 'tag', {\\n\\t\\t'script': {\\n\\t\\t\\tpattern: /(<script[\\\\w\\\\W]*?>)[\\\\w\\\\W]*?(?=<\\\\/script>)/i,\\n\\t\\t\\tlookbehind: true,\\n\\t\\t\\tinside: Prism.languages.javascript,\\n\\t\\t\\talias: 'language-javascript'\\n\\t\\t}\\n\\t});\\n}\\n\\nPrism.languages.js = Prism.languages.javascript;\\n\\n/* **********************************************\\n     Begin prism-file-highlight.js\\n********************************************** */\\n\\n(function () {\\n\\tif (typeof self === 'undefined' || !self.Prism || !self.document || !document.querySelector) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tself.Prism.fileHighlight = function() {\\n\\n\\t\\tvar Extensions = {\\n\\t\\t\\t'js': 'javascript',\\n\\t\\t\\t'py': 'python',\\n\\t\\t\\t'rb': 'ruby',\\n\\t\\t\\t'ps1': 'powershell',\\n\\t\\t\\t'psm1': 'powershell',\\n\\t\\t\\t'sh': 'bash',\\n\\t\\t\\t'bat': 'batch',\\n\\t\\t\\t'h': 'c',\\n\\t\\t\\t'tex': 'latex'\\n\\t\\t};\\n\\n\\t\\tif(Array.prototype.forEach) { // Check to prevent error in IE8\\n\\t\\t\\tArray.prototype.slice.call(document.querySelectorAll('pre[data-src]')).forEach(function (pre) {\\n\\t\\t\\t\\tvar src = pre.getAttribute('data-src');\\n\\n\\t\\t\\t\\tvar language, parent = pre;\\n\\t\\t\\t\\tvar lang = /\\\\blang(?:uage)?-(?!\\\\*)(\\\\w+)\\\\b/i;\\n\\t\\t\\t\\twhile (parent && !lang.test(parent.className)) {\\n\\t\\t\\t\\t\\tparent = parent.parentNode;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (parent) {\\n\\t\\t\\t\\t\\tlanguage = (pre.className.match(lang) || [, ''])[1];\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (!language) {\\n\\t\\t\\t\\t\\tvar extension = (src.match(/\\\\.(\\\\w+)$/) || [, ''])[1];\\n\\t\\t\\t\\t\\tlanguage = Extensions[extension] || extension;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvar code = document.createElement('code');\\n\\t\\t\\t\\tcode.className = 'language-' + language;\\n\\n\\t\\t\\t\\tpre.textContent = '';\\n\\n\\t\\t\\t\\tcode.textContent = 'Loading…';\\n\\n\\t\\t\\t\\tpre.appendChild(code);\\n\\n\\t\\t\\t\\tvar xhr = new XMLHttpRequest();\\n\\n\\t\\t\\t\\txhr.open('GET', src, true);\\n\\n\\t\\t\\t\\txhr.onreadystatechange = function () {\\n\\t\\t\\t\\t\\tif (xhr.readyState == 4) {\\n\\n\\t\\t\\t\\t\\t\\tif (xhr.status < 400 && xhr.responseText) {\\n\\t\\t\\t\\t\\t\\t\\tcode.textContent = xhr.responseText;\\n\\n\\t\\t\\t\\t\\t\\t\\tPrism.highlightElement(code);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse if (xhr.status >= 400) {\\n\\t\\t\\t\\t\\t\\t\\tcode.textContent = '✖ Error ' + xhr.status + ' while fetching file: ' + xhr.statusText;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\t\\tcode.textContent = '✖ Error: File does not exist or is empty';\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\txhr.send(null);\\n\\t\\t\\t});\\n\\t\\t}\\n\\n\\t};\\n\\n\\tdocument.addEventListener('DOMContentLoaded', self.Prism.fileHighlight);\\n\\n})();\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/adebisi/Public/ng2-split/~/raw-loader!/home/adebisi/Public/ng2-split/~/prismjs/prism.js\n// module id = 648\n// module chunks = 2","module.exports = \"// The programming goals of Split.js are to deliver readable, understandable and\\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\\n// and very few assumptions about the user's page layout.\\n//\\n// Make sure all browsers handle this JS library correctly with ES5.\\n// More information here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\\n'use strict';\\n\\n// A wrapper function that does a couple things:\\n//\\n// 1. Doesn't pollute the global namespace. This is important for a library.\\n// 2. Allows us to mount the library in different module systems, as well as\\n//    directly in the browser.\\n(function() {\\n\\n// Save the global `this` for use later. In this case, since the library only\\n// runs in the browser, it will refer to `window`. Also, figure out if we're in IE8\\n// or not. IE8 will still render correctly, but will be static instead of draggable.\\n//\\n// Save a couple long function names that are used frequently.\\n// This optimization saves around 400 bytes.\\nvar global = this\\n  , isIE8 = global.attachEvent && !global[addEventListener]\\n  , document = global.document\\n  , addEventListener = 'addEventListener'\\n  , removeEventListener = 'removeEventListener'\\n  , getBoundingClientRect = 'getBoundingClientRect'\\n\\n  // This library only needs two helper functions:\\n  //\\n  // The first determines which prefixes of CSS calc we need.\\n  // We only need to do this once on startup, when this anonymous function is called.\\n  // \\n  // Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\\n  // http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\\n  , calc = (function () {\\n        var el\\n          , prefixes = [\\\"\\\", \\\"-webkit-\\\", \\\"-moz-\\\", \\\"-o-\\\"]\\n\\n        for (var i = 0; i < prefixes.length; i++) {\\n            el = document.createElement('div')\\n            el.style.cssText = \\\"width:\\\" + prefixes[i] + \\\"calc(9px)\\\"\\n\\n            if (el.style.length) {\\n                return prefixes[i] + \\\"calc\\\"\\n            }\\n        }\\n    })()\\n\\n  // The second helper function allows elements and string selectors to be used\\n  // interchangeably. In either case an element is returned. This allows us to\\n  // do `Split(elem1, elem2)` as well as `Split('#id1', '#id2')`.\\n  , elementOrSelector = function (el) {\\n        if (typeof el === 'string' || el instanceof String) {\\n            return document.querySelector(el)\\n        } else {\\n            return el\\n        }\\n    }\\n\\n  // The main function to initialize a split. Split.js thinks about each pair\\n  // of elements as an independant pair. Dragging the gutter between two elements\\n  // only changes the dimensions of elements in that pair. This is key to understanding\\n  // how the following functions operate, since each function is bound to a pair.\\n  // \\n  // A pair object is shaped like this:\\n  // \\n  // {\\n  //     a: DOM element,\\n  //     b: DOM element,\\n  //     aMin: Number,\\n  //     bMin: Number,\\n  //     dragging: Boolean,\\n  //     parent: DOM element,\\n  //     isFirst: Boolean,\\n  //     isLast: Boolean,\\n  //     direction: 'horizontal' | 'vertical'\\n  // }\\n  //\\n  // The basic sequence:\\n  // \\n  // 1. Set defaults to something sane. `options` doesn't have to be passed at all.\\n  // 2. Initialize a bunch of strings based on the direction we're splitting.\\n  //    A lot of the behavior in the rest of the library is paramatized down to\\n  //    rely on CSS strings and classes.\\n  // 3. Define the dragging helper functions, and a few helpers to go with them.\\n  // 4. Define a few more functions that \\\"balance\\\" the entire split instance.\\n  //    Split.js tries it's best to cope with min sizes that don't add up.\\n  // 5. Loop through the elements while pairing them off. Every pair gets an\\n  //    `pair` object, a gutter, and special isFirst/isLast properties.\\n  // 6. Actually size the pair elements, insert gutters and attach event listeners.\\n  // 7. Balance all of the pairs to accomodate min sizes as best as possible.\\n  , Split = function (ids, options) {\\n    var dimension\\n      , i\\n      , clientDimension\\n      , clientAxis\\n      , position\\n      , gutterClass\\n      , paddingA\\n      , paddingB\\n      , pairs = []\\n\\n    // 1. Set defaults to something sane. `options` doesn't have to be passed at all,\\n    // so create an options object if none exists. Pixel values 10, 100 and 30 are\\n    // arbitrary but feel natural.\\n    options = typeof options !== 'undefined' ?  options : {}\\n\\n    if (typeof options.gutterSize === 'undefined') options.gutterSize = 10\\n    if (typeof options.minSize === 'undefined') options.minSize = 100\\n    if (typeof options.snapOffset === 'undefined') options.snapOffset = 30\\n    if (typeof options.direction === 'undefined') options.direction = 'horizontal'\\n\\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\\n    // A lot of the behavior in the rest of the library is paramatized down to\\n    // rely on CSS strings and classes.\\n    if (options.direction == 'horizontal') {\\n        dimension = 'width'\\n        clientDimension = 'clientWidth'\\n        clientAxis = 'clientX'\\n        position = 'left'\\n        gutterClass = 'gutter gutter-horizontal'\\n        paddingA = 'paddingLeft'\\n        paddingB = 'paddingRight'\\n        if (!options.cursor) options.cursor = 'ew-resize'\\n    } else if (options.direction == 'vertical') {\\n        dimension = 'height'\\n        clientDimension = 'clientHeight'\\n        clientAxis = 'clientY'\\n        position = 'top'\\n        gutterClass = 'gutter gutter-vertical'\\n        paddingA = 'paddingTop'\\n        paddingB = 'paddingBottom'\\n        if (!options.cursor) options.cursor = 'ns-resize'\\n    }\\n\\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\\n    // Each helper is bound to a pair object that contains it's metadata. This\\n    // also makes it easy to store references to listeners that that will be\\n    // added and removed.\\n    // \\n    // Even though there are no other functions contained in them, aliasing\\n    // this to self saves 50 bytes or so since it's used so frequently.\\n    //\\n    // The pair object saves metadata like dragging state, position and\\n    // event listener references.\\n    //\\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\\n    // It also adds event listeners for mouse/touch events,\\n    // and prevents selection while dragging so avoid the selecting text.\\n    var startDragging = function (e) {\\n            // Alias frequently used variables to save space. 200 bytes.\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            // Call the onDragStart callback.\\n            if (!self.dragging && options.onDragStart) {\\n                options.onDragStart()\\n            }\\n\\n            // Don't actually drag the element. We emulate that in the drag function.\\n            e.preventDefault()\\n\\n            // Set the dragging property of the pair object.\\n            self.dragging = true\\n\\n            // Create two event listeners bound to the same pair object and store\\n            // them in the pair object.\\n            self.move = drag.bind(self)\\n            self.stop = stopDragging.bind(self)\\n\\n            // All the binding. `window` gets the stop events in case we drag out of the elements.\\n            global[addEventListener]('mouseup', self.stop)\\n            global[addEventListener]('touchend', self.stop)\\n            global[addEventListener]('touchcancel', self.stop)\\n\\n            self.parent[addEventListener]('mousemove', self.move)\\n            self.parent[addEventListener]('touchmove', self.move)\\n\\n            // Disable selection. Disable!\\n            a[addEventListener]('selectstart', noop)\\n            a[addEventListener]('dragstart', noop)\\n            b[addEventListener]('selectstart', noop)\\n            b[addEventListener]('dragstart', noop)\\n\\n            a.style.userSelect = 'none'\\n            a.style.webkitUserSelect = 'none'\\n            a.style.MozUserSelect = 'none'\\n            a.style.pointerEvents = 'none'\\n\\n            b.style.userSelect = 'none'\\n            b.style.webkitUserSelect = 'none'\\n            b.style.MozUserSelect = 'none'\\n            b.style.pointerEvents = 'none'\\n\\n            // Set the cursor, both on the gutter and the parent element.\\n            // Doing only a, b and gutter causes flickering.\\n            self.gutter.style.cursor = options.cursor\\n            self.parent.style.cursor = options.cursor\\n\\n            // Cache the initial sizes of the pair.\\n            calculateSizes.call(self)\\n        }\\n\\n      // stopDragging is very similar to startDragging in reverse.\\n      , stopDragging = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (self.dragging && options.onDragEnd) {\\n                options.onDragEnd()\\n            }\\n\\n            self.dragging = false\\n\\n            // Remove the stored event listeners. This is why we store them.\\n            global[removeEventListener]('mouseup', self.stop)\\n            global[removeEventListener]('touchend', self.stop)\\n            global[removeEventListener]('touchcancel', self.stop)\\n\\n            self.parent[removeEventListener]('mousemove', self.move)\\n            self.parent[removeEventListener]('touchmove', self.move)\\n\\n            // Delete them once they are removed. I think this makes a difference\\n            // in memory usage with a lot of splits on one page. But I don't know for sure.\\n            delete self.stop\\n            delete self.move\\n\\n            a[removeEventListener]('selectstart', noop)\\n            a[removeEventListener]('dragstart', noop)\\n            b[removeEventListener]('selectstart', noop)\\n            b[removeEventListener]('dragstart', noop)\\n\\n            a.style.userSelect = ''\\n            a.style.webkitUserSelect = ''\\n            a.style.MozUserSelect = ''\\n            a.style.pointerEvents = ''\\n\\n            b.style.userSelect = ''\\n            b.style.webkitUserSelect = ''\\n            b.style.MozUserSelect = ''\\n            b.style.pointerEvents = ''\\n\\n            self.gutter.style.cursor = ''\\n            self.parent.style.cursor = ''\\n        }\\n\\n      // drag, where all the magic happens. The logic is really quite simple:\\n      // \\n      // 1. Ignore if the pair is not dragging.\\n      // 2. Get the offset of the event.\\n      // 3. Snap offset to min if within snappable range (within min + snapOffset).\\n      // 4. Actually adjust each element in the pair to offset.\\n      // \\n      // ---------------------------------------------------------------------\\n      // |    | <- this.aMin               ||              this.bMin -> |    |\\n      // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\\n      // |    |  |                         ||                        |  |    |\\n      // |    |  |                         ||                        |  |    |\\n      // ---------------------------------------------------------------------\\n      // | <- this.start                                        this.size -> |\\n      , drag = function (e) {\\n            var offset\\n\\n            if (!this.dragging) return\\n\\n            // Get the offset of the event from the first side of the\\n            // pair `this.start`. Supports touch events, but not multitouch, so only the first\\n            // finger `touches[0]` is counted.\\n            if ('touches' in e) {\\n                offset = e.touches[0][clientAxis] - this.start\\n            } else {\\n                offset = e[clientAxis] - this.start\\n            }\\n\\n            // If within snapOffset of min or max, set offset to min or max.\\n            // snapOffset buffers aMin and bMin, so logic is opposite for both.\\n            // Include the appropriate gutter sizes to prevent overflows.\\n            if (offset <= this.aMin + options.snapOffset + this.aGutterSize) {\\n                offset = this.aMin + this.aGutterSize\\n            } else if (offset >= this.size - (this.bMin + options.snapOffset + this.bGutterSize)) {\\n                offset = this.size - (this.bMin + this.bGutterSize)\\n            }\\n\\n            // Actually adjust the size.\\n            adjust.call(this, offset)\\n\\n            // Call the drag callback continously. Don't do anything too intensive\\n            // in this callback.\\n            if (options.onDrag) {\\n                options.onDrag()\\n            }\\n        }\\n\\n      // Cache some important sizes when drag starts, so we don't have to do that\\n      // continously:\\n      // \\n      // `size`: The total size of the pair. First element + second element + first gutter + second gutter.\\n      // `percentage`: The percentage between 0-100 that the pair occupies in the parent.\\n      // `start`: The leading side of the first element.\\n      //\\n      // ------------------------------------------------ - - - - - - - - - - -\\n      // |      aGutterSize -> |||                      |                     |\\n      // |                     |||                      |                     |\\n      // |                     |||                      |                     |\\n      // |                     ||| <- bGutterSize       |                     |\\n      // ------------------------------------------------ - - - - - - - - - - -\\n      // | <- start                             size -> |       parentSize -> |\\n      , calculateSizes = function () {\\n            // Figure out the parent size minus padding.\\n            var computedStyle = global.getComputedStyle(this.parent)\\n              , parentSize = this.parent[clientDimension] - parseFloat(computedStyle[paddingA]) - parseFloat(computedStyle[paddingB])\\n\\n            this.size = this.a[getBoundingClientRect]()[dimension] + this.b[getBoundingClientRect]()[dimension] + this.aGutterSize + this.bGutterSize\\n            this.percentage = Math.min(this.size / parentSize * 100, 100)\\n            this.start = this.a[getBoundingClientRect]()[position]\\n        }\\n\\n      // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\\n      // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\\n      // which allows the viewport to be resized without additional logic.\\n      // Element a's size is the same as offset. b's size is total size - a size.\\n      // Both sizes are calculated from the initial parent percentage, then the gutter size is subtracted.\\n      , adjust = function (offset) {\\n            this.a.style[dimension] = calc + '(' + (offset / this.size * this.percentage) + '% - ' + this.aGutterSize + 'px)'\\n            this.b.style[dimension] = calc + '(' + (this.percentage - (offset / this.size * this.percentage)) + '% - ' + this.bGutterSize + 'px)'\\n        }\\n\\n      // 4. Define a few more functions that \\\"balance\\\" the entire split instance.\\n      // Split.js tries it's best to cope with min sizes that don't add up.\\n      // At some point this should go away since it breaks out of the calc(% - px) model.\\n      // Maybe it's a user error if you pass uncomputable minSizes.\\n      , fitMin = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (a[getBoundingClientRect]()[dimension] < self.aMin) {\\n                a.style[dimension] = (self.aMin - self.aGutterSize) + 'px'\\n                b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px'\\n            } else if (b[getBoundingClientRect]()[dimension] < self.bMin) {\\n                a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px'\\n                b.style[dimension] = (self.bMin - self.bGutterSize) + 'px'\\n            }\\n        }\\n      , fitMinReverse = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (b[getBoundingClientRect]()[dimension] < self.bMin) {\\n                a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px'\\n                b.style[dimension] = (self.bMin - self.bGutterSize) + 'px'\\n            } else if (a[getBoundingClientRect]()[dimension] < self.aMin) {\\n                a.style[dimension] = (self.aMin - self.aGutterSize) + 'px'\\n                b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px'\\n            }\\n        }\\n      , balancePairs = function (pairs) {\\n            for (var i = 0; i < pairs.length; i++) {\\n                calculateSizes.call(pairs[i])\\n                fitMin.call(pairs[i])\\n            }\\n\\n            for (i = pairs.length - 1; i >= 0; i--) {\\n                calculateSizes.call(pairs[i])\\n                fitMinReverse.call(pairs[i])\\n            }\\n        }\\n      , setElementSize = function (el, size, gutterSize) {\\n            // Split.js allows setting sizes via numbers (ideally), or if you must,\\n            // by string, like '300px'. This is less than ideal, because it breaks\\n            // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\\n            // make sure you calculate the gutter size by hand.\\n            if (typeof size !== 'string' && !(size instanceof String)) {\\n                if (!isIE8) {\\n                    size = calc + '(' + size + '% - ' + gutterSize + 'px)'\\n                } else {\\n                    size = options.sizes[i] + '%'\\n                }\\n            }\\n\\n            el.style[dimension] = size\\n        }\\n\\n      // No-op function to prevent default. Used to prevent selection.\\n      , noop = function () { return false }\\n\\n      // All DOM elements in the split should have a common parent. We can grab\\n      // the first elements parent and hope users read the docs because the\\n      // behavior will be whacky otherwise.\\n      , parent = elementOrSelector(ids[0]).parentNode\\n\\n    // Set default options.sizes to equal percentages of the parent element.\\n    if (!options.sizes) {\\n        var percent = 100 / ids.length\\n\\n        options.sizes = []\\n\\n        for (i = 0; i < ids.length; i++) {\\n            options.sizes.push(percent)\\n        }\\n    }\\n\\n    // Standardize minSize to an array if it isn't already. This allows minSize\\n    // to be passed as a number.\\n    if (!Array.isArray(options.minSize)) {\\n        var minSizes = []\\n\\n        for (i = 0; i < ids.length; i++) {\\n            minSizes.push(options.minSize)\\n        }\\n\\n        options.minSize = minSizes\\n    }\\n\\n    // 5. Loop through the elements while pairing them off. Every pair gets a\\n    // `pair` object, a gutter, and isFirst/isLast properties.\\n    //\\n    // Basic logic:\\n    //\\n    // - Starting with the second element `i > 0`, create `pair` objects with\\n    //   `a = ids[i - 1]` and `b = ids[i]`\\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\\n    // - Create gutter elements and add event listeners.\\n    // - Set the size of the elements, minus the gutter sizes.\\n    //\\n    // -----------------------------------------------------------------------\\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\\n    // |             |       isFirst       |                  |     isLast   |\\n    // |           pair 0                pair 1             pair 2           |\\n    // |             |                     |                  |              |\\n    // -----------------------------------------------------------------------\\n    for (i = 0; i < ids.length; i++) {\\n        var el = elementOrSelector(ids[i])\\n          , isFirstPair = (i == 1)\\n          , isLastPair = (i == ids.length - 1)\\n          , size = options.sizes[i]\\n          , gutterSize = options.gutterSize\\n          , pair\\n\\n        if (i > 0) {\\n            // Create the pair object with it's metadata.\\n            pair = {\\n                a: elementOrSelector(ids[i - 1]),\\n                b: el,\\n                aMin: options.minSize[i - 1],\\n                bMin: options.minSize[i],\\n                dragging: false,\\n                parent: parent,\\n                isFirst: isFirstPair,\\n                isLast: isLastPair,\\n                direction: options.direction\\n            }\\n\\n            // For first and last pairs, first and last gutter width is half.\\n            pair.aGutterSize = options.gutterSize\\n            pair.bGutterSize = options.gutterSize\\n\\n            if (isFirstPair) {\\n                pair.aGutterSize = options.gutterSize / 2\\n            }\\n\\n            if (isLastPair) {\\n                pair.bGutterSize = options.gutterSize / 2\\n            }\\n        }\\n\\n        // Determine the size of the current element. IE8 is supported by\\n        // staticly assigning sizes without draggable gutters. Assigns a string\\n        // to `size`.\\n        // \\n        // IE9 and above\\n        if (!isIE8) {\\n            // Create gutter elements for each pair.\\n            if (i > 0) {\\n                var gutter = document.createElement('div')\\n\\n                gutter.className = gutterClass\\n                gutter.style[dimension] = options.gutterSize + 'px'\\n\\n                gutter[addEventListener]('mousedown', startDragging.bind(pair))\\n                gutter[addEventListener]('touchstart', startDragging.bind(pair))\\n\\n                parent.insertBefore(gutter, el)\\n\\n                pair.gutter = gutter\\n            }\\n\\n            // Half-size gutters for first and last elements.\\n            if (i === 0 || i == ids.length - 1) {\\n                gutterSize = options.gutterSize / 2\\n            }\\n        }\\n\\n        // Set the element size to our determined size.\\n        setElementSize(el, size, gutterSize)\\n\\n        // After the first iteration, and we have a pair object, append it to the\\n        // list of pairs.\\n        if (i > 0) {\\n            pairs.push(pair)\\n        }\\n    }\\n\\n    // Balance the pairs to try to accomodate min sizes.\\n    balancePairs(pairs)\\n\\n    return {\\n        setSizes: function (sizes) {\\n            for (var i = 0; i < sizes.length; i++) {\\n                if (i > 0) {\\n                    var pair = pairs[i - 1]\\n\\n                    setElementSize(pair.a, sizes[i - 1], pair.aGutterSize)\\n                    setElementSize(pair.b, sizes[i], pair.bGutterSize)\\n                }\\n            }\\n        },\\n        collapse: function (i) {\\n            var pair\\n\\n            if (i === pairs.length) {\\n                pair = pairs[i - 1]\\n\\n                calculateSizes.call(pair)\\n                adjust.call(pair, pair.size - pair.bGutterSize)\\n            } else {\\n                pair = pairs[i]\\n\\n                calculateSizes.call(pair)\\n                adjust.call(pair, pair.aGutterSize)\\n            }\\n        },\\n        destroy: function () {\\n            for (var i = 0; i < pairs.length; i++) {\\n                pairs[i].parent.removeChild(pairs[i].gutter)\\n                pairs[i].a.style[dimension] = ''\\n                pairs[i].b.style[dimension] = ''\\n            }\\n        }\\n    }\\n}\\n\\n// Play nicely with module systems, and the browser too if you include it raw.\\nif (typeof exports !== 'undefined') {\\n    if (typeof module !== 'undefined' && module.exports) {\\n        exports = module.exports = Split\\n    }\\n    exports.Split = Split\\n} else {\\n    global.Split = Split\\n}\\n\\n// Call our wrapper function with the current global. In this case, `window`.\\n}).call(window);\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/adebisi/Public/ng2-split/~/raw-loader!/home/adebisi/Public/ng2-split/~/split.js/split.js\n// module id = 649\n// module chunks = 2"],"sourceRoot":""}