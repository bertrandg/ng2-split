{"version":3,"sources":["webpack:///scripts.c1644f851edaba09829d.bundle.js","webpack:////home/adebisi/Public/testCli/~/split.js/split.js?7b3d","webpack:////home/adebisi/Public/testCli/~/split.js/split.js","webpack:////home/adebisi/Public/testCli/~/script-loader/addScript.js"],"names":["webpackJsonp","334","module","exports","__webpack_require__","593","613","src","execScript","eval","call","617"],"mappings":"AAAAA,cAAc,EAAE,IAEVC,IACA,SAASC,EAAQC,EAASC,GCHhCA,EAAA,KAAAA,EAAA,ODSMC,IACA,SAASH,EAAQC,GEVvBD,EAAAC,QAAA,o0uBFgBMG,IACA,SAASJ,EAAQC,GGbvBD,EAAAC,QAAA,SAAAI,GACA,mBAAAC,YACAA,WAAAD,GAEAE,KAAAC,KAAA,KAAAH,KHyBMI,IACA,SAAST,EAAQC,EAASC,GAEhCF,EAAOC,QAAUC,EAAoB,QAKlC","file":"scripts.c1644f851edaba09829d.bundle.js","sourcesContent":["webpackJsonp([2,3],{\n\n/***/ 334:\n/***/ function(module, exports, __webpack_require__) {\n\n__webpack_require__(613)(__webpack_require__(593))\n\n/***/ },\n\n/***/ 593:\n/***/ function(module, exports) {\n\nmodule.exports = \"// The programming goals of Split.js are to deliver readable, understandable and\\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\\n// and very few assumptions about the user's page layout.\\n//\\n// Make sure all browsers handle this JS library correctly with ES5.\\n// More information here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\\n'use strict';\\n\\n// A wrapper function that does a couple things:\\n//\\n// 1. Doesn't pollute the global namespace. This is important for a library.\\n// 2. Allows us to mount the library in different module systems, as well as\\n//    directly in the browser.\\n(function() {\\n\\n// Save the global `this` for use later. In this case, since the library only\\n// runs in the browser, it will refer to `window`. Also, figure out if we're in IE8\\n// or not. IE8 will still render correctly, but will be static instead of draggable.\\n//\\n// Save a couple long function names that are used frequently.\\n// This optimization saves around 400 bytes.\\nvar global = this\\n  , isIE8 = global.attachEvent && !global[addEventListener]\\n  , document = global.document\\n  , addEventListener = 'addEventListener'\\n  , removeEventListener = 'removeEventListener'\\n  , getBoundingClientRect = 'getBoundingClientRect'\\n\\n  // This library only needs two helper functions:\\n  //\\n  // The first determines which prefixes of CSS calc we need.\\n  // We only need to do this once on startup, when this anonymous function is called.\\n  // \\n  // Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\\n  // http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\\n  , calc = (function () {\\n        var el\\n          , prefixes = [\\\"\\\", \\\"-webkit-\\\", \\\"-moz-\\\", \\\"-o-\\\"]\\n\\n        for (var i = 0; i < prefixes.length; i++) {\\n            el = document.createElement('div')\\n            el.style.cssText = \\\"width:\\\" + prefixes[i] + \\\"calc(9px)\\\"\\n\\n            if (el.style.length) {\\n                return prefixes[i] + \\\"calc\\\"\\n            }\\n        }\\n    })()\\n\\n  // The second helper function allows elements and string selectors to be used\\n  // interchangeably. In either case an element is returned. This allows us to\\n  // do `Split(elem1, elem2)` as well as `Split('#id1', '#id2')`.\\n  , elementOrSelector = function (el) {\\n        if (typeof el === 'string' || el instanceof String) {\\n            return document.querySelector(el)\\n        } else {\\n            return el\\n        }\\n    }\\n\\n  // The main function to initialize a split. Split.js thinks about each pair\\n  // of elements as an independant pair. Dragging the gutter between two elements\\n  // only changes the dimensions of elements in that pair. This is key to understanding\\n  // how the following functions operate, since each function is bound to a pair.\\n  // \\n  // A pair object is shaped like this:\\n  // \\n  // {\\n  //     a: DOM element,\\n  //     b: DOM element,\\n  //     aMin: Number,\\n  //     bMin: Number,\\n  //     dragging: Boolean,\\n  //     parent: DOM element,\\n  //     isFirst: Boolean,\\n  //     isLast: Boolean,\\n  //     direction: 'horizontal' | 'vertical'\\n  // }\\n  //\\n  // The basic sequence:\\n  // \\n  // 1. Set defaults to something sane. `options` doesn't have to be passed at all.\\n  // 2. Initialize a bunch of strings based on the direction we're splitting.\\n  //    A lot of the behavior in the rest of the library is paramatized down to\\n  //    rely on CSS strings and classes.\\n  // 3. Define the dragging helper functions, and a few helpers to go with them.\\n  // 4. Define a few more functions that \\\"balance\\\" the entire split instance.\\n  //    Split.js tries it's best to cope with min sizes that don't add up.\\n  // 5. Loop through the elements while pairing them off. Every pair gets an\\n  //    `pair` object, a gutter, and special isFirst/isLast properties.\\n  // 6. Actually size the pair elements, insert gutters and attach event listeners.\\n  // 7. Balance all of the pairs to accomodate min sizes as best as possible.\\n  , Split = function (ids, options) {\\n    var dimension\\n      , i\\n      , clientDimension\\n      , clientAxis\\n      , position\\n      , gutterClass\\n      , paddingA\\n      , paddingB\\n      , pairs = []\\n\\n    // 1. Set defaults to something sane. `options` doesn't have to be passed at all,\\n    // so create an options object if none exists. Pixel values 10, 100 and 30 are\\n    // arbitrary but feel natural.\\n    options = typeof options !== 'undefined' ?  options : {}\\n\\n    if (typeof options.gutterSize === 'undefined') options.gutterSize = 10\\n    if (typeof options.minSize === 'undefined') options.minSize = 100\\n    if (typeof options.snapOffset === 'undefined') options.snapOffset = 30\\n    if (typeof options.direction === 'undefined') options.direction = 'horizontal'\\n\\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\\n    // A lot of the behavior in the rest of the library is paramatized down to\\n    // rely on CSS strings and classes.\\n    if (options.direction == 'horizontal') {\\n        dimension = 'width'\\n        clientDimension = 'clientWidth'\\n        clientAxis = 'clientX'\\n        position = 'left'\\n        gutterClass = 'gutter gutter-horizontal'\\n        paddingA = 'paddingLeft'\\n        paddingB = 'paddingRight'\\n        if (!options.cursor) options.cursor = 'ew-resize'\\n    } else if (options.direction == 'vertical') {\\n        dimension = 'height'\\n        clientDimension = 'clientHeight'\\n        clientAxis = 'clientY'\\n        position = 'top'\\n        gutterClass = 'gutter gutter-vertical'\\n        paddingA = 'paddingTop'\\n        paddingB = 'paddingBottom'\\n        if (!options.cursor) options.cursor = 'ns-resize'\\n    }\\n\\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\\n    // Each helper is bound to a pair object that contains it's metadata. This\\n    // also makes it easy to store references to listeners that that will be\\n    // added and removed.\\n    // \\n    // Even though there are no other functions contained in them, aliasing\\n    // this to self saves 50 bytes or so since it's used so frequently.\\n    //\\n    // The pair object saves metadata like dragging state, position and\\n    // event listener references.\\n    //\\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\\n    // It also adds event listeners for mouse/touch events,\\n    // and prevents selection while dragging so avoid the selecting text.\\n    var startDragging = function (e) {\\n            // Alias frequently used variables to save space. 200 bytes.\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            // Call the onDragStart callback.\\n            if (!self.dragging && options.onDragStart) {\\n                options.onDragStart()\\n            }\\n\\n            // Don't actually drag the element. We emulate that in the drag function.\\n            e.preventDefault()\\n\\n            // Set the dragging property of the pair object.\\n            self.dragging = true\\n\\n            // Create two event listeners bound to the same pair object and store\\n            // them in the pair object.\\n            self.move = drag.bind(self)\\n            self.stop = stopDragging.bind(self)\\n\\n            // All the binding. `window` gets the stop events in case we drag out of the elements.\\n            global[addEventListener]('mouseup', self.stop)\\n            global[addEventListener]('touchend', self.stop)\\n            global[addEventListener]('touchcancel', self.stop)\\n\\n            self.parent[addEventListener]('mousemove', self.move)\\n            self.parent[addEventListener]('touchmove', self.move)\\n\\n            // Disable selection. Disable!\\n            a[addEventListener]('selectstart', noop)\\n            a[addEventListener]('dragstart', noop)\\n            b[addEventListener]('selectstart', noop)\\n            b[addEventListener]('dragstart', noop)\\n\\n            a.style.userSelect = 'none'\\n            a.style.webkitUserSelect = 'none'\\n            a.style.MozUserSelect = 'none'\\n            a.style.pointerEvents = 'none'\\n\\n            b.style.userSelect = 'none'\\n            b.style.webkitUserSelect = 'none'\\n            b.style.MozUserSelect = 'none'\\n            b.style.pointerEvents = 'none'\\n\\n            // Set the cursor, both on the gutter and the parent element.\\n            // Doing only a, b and gutter causes flickering.\\n            self.gutter.style.cursor = options.cursor\\n            self.parent.style.cursor = options.cursor\\n\\n            // Cache the initial sizes of the pair.\\n            calculateSizes.call(self)\\n        }\\n\\n      // stopDragging is very similar to startDragging in reverse.\\n      , stopDragging = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (self.dragging && options.onDragEnd) {\\n                options.onDragEnd()\\n            }\\n\\n            self.dragging = false\\n\\n            // Remove the stored event listeners. This is why we store them.\\n            global[removeEventListener]('mouseup', self.stop)\\n            global[removeEventListener]('touchend', self.stop)\\n            global[removeEventListener]('touchcancel', self.stop)\\n\\n            self.parent[removeEventListener]('mousemove', self.move)\\n            self.parent[removeEventListener]('touchmove', self.move)\\n\\n            // Delete them once they are removed. I think this makes a difference\\n            // in memory usage with a lot of splits on one page. But I don't know for sure.\\n            delete self.stop\\n            delete self.move\\n\\n            a[removeEventListener]('selectstart', noop)\\n            a[removeEventListener]('dragstart', noop)\\n            b[removeEventListener]('selectstart', noop)\\n            b[removeEventListener]('dragstart', noop)\\n\\n            a.style.userSelect = ''\\n            a.style.webkitUserSelect = ''\\n            a.style.MozUserSelect = ''\\n            a.style.pointerEvents = ''\\n\\n            b.style.userSelect = ''\\n            b.style.webkitUserSelect = ''\\n            b.style.MozUserSelect = ''\\n            b.style.pointerEvents = ''\\n\\n            self.gutter.style.cursor = ''\\n            self.parent.style.cursor = ''\\n        }\\n\\n      // drag, where all the magic happens. The logic is really quite simple:\\n      // \\n      // 1. Ignore if the pair is not dragging.\\n      // 2. Get the offset of the event.\\n      // 3. Snap offset to min if within snappable range (within min + snapOffset).\\n      // 4. Actually adjust each element in the pair to offset.\\n      // \\n      // ---------------------------------------------------------------------\\n      // |    | <- this.aMin               ||              this.bMin -> |    |\\n      // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\\n      // |    |  |                         ||                        |  |    |\\n      // |    |  |                         ||                        |  |    |\\n      // ---------------------------------------------------------------------\\n      // | <- this.start                                        this.size -> |\\n      , drag = function (e) {\\n            var offset\\n\\n            if (!this.dragging) return\\n\\n            // Get the offset of the event from the first side of the\\n            // pair `this.start`. Supports touch events, but not multitouch, so only the first\\n            // finger `touches[0]` is counted.\\n            if ('touches' in e) {\\n                offset = e.touches[0][clientAxis] - this.start\\n            } else {\\n                offset = e[clientAxis] - this.start\\n            }\\n\\n            // If within snapOffset of min or max, set offset to min or max.\\n            // snapOffset buffers aMin and bMin, so logic is opposite for both.\\n            // Include the appropriate gutter sizes to prevent overflows.\\n            if (offset <= this.aMin + options.snapOffset + this.aGutterSize) {\\n                offset = this.aMin + this.aGutterSize\\n            } else if (offset >= this.size - (this.bMin + options.snapOffset + this.bGutterSize)) {\\n                offset = this.size - (this.bMin + this.bGutterSize)\\n            }\\n\\n            // Actually adjust the size.\\n            adjust.call(this, offset)\\n\\n            // Call the drag callback continously. Don't do anything too intensive\\n            // in this callback.\\n            if (options.onDrag) {\\n                options.onDrag()\\n            }\\n        }\\n\\n      // Cache some important sizes when drag starts, so we don't have to do that\\n      // continously:\\n      // \\n      // `size`: The total size of the pair. First element + second element + first gutter + second gutter.\\n      // `percentage`: The percentage between 0-100 that the pair occupies in the parent.\\n      // `start`: The leading side of the first element.\\n      //\\n      // ------------------------------------------------ - - - - - - - - - - -\\n      // |      aGutterSize -> |||                      |                     |\\n      // |                     |||                      |                     |\\n      // |                     |||                      |                     |\\n      // |                     ||| <- bGutterSize       |                     |\\n      // ------------------------------------------------ - - - - - - - - - - -\\n      // | <- start                             size -> |       parentSize -> |\\n      , calculateSizes = function () {\\n            // Figure out the parent size minus padding.\\n            var computedStyle = global.getComputedStyle(this.parent)\\n              , parentSize = this.parent[clientDimension] - parseFloat(computedStyle[paddingA]) - parseFloat(computedStyle[paddingB])\\n\\n            this.size = this.a[getBoundingClientRect]()[dimension] + this.b[getBoundingClientRect]()[dimension] + this.aGutterSize + this.bGutterSize\\n            this.percentage = Math.min(this.size / parentSize * 100, 100)\\n            this.start = this.a[getBoundingClientRect]()[position]\\n        }\\n\\n      // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\\n      // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\\n      // which allows the viewport to be resized without additional logic.\\n      // Element a's size is the same as offset. b's size is total size - a size.\\n      // Both sizes are calculated from the initial parent percentage, then the gutter size is subtracted.\\n      , adjust = function (offset) {\\n            this.a.style[dimension] = calc + '(' + (offset / this.size * this.percentage) + '% - ' + this.aGutterSize + 'px)'\\n            this.b.style[dimension] = calc + '(' + (this.percentage - (offset / this.size * this.percentage)) + '% - ' + this.bGutterSize + 'px)'\\n        }\\n\\n      // 4. Define a few more functions that \\\"balance\\\" the entire split instance.\\n      // Split.js tries it's best to cope with min sizes that don't add up.\\n      // At some point this should go away since it breaks out of the calc(% - px) model.\\n      // Maybe it's a user error if you pass uncomputable minSizes.\\n      , fitMin = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (a[getBoundingClientRect]()[dimension] < self.aMin) {\\n                a.style[dimension] = (self.aMin - self.aGutterSize) + 'px'\\n                b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px'\\n            } else if (b[getBoundingClientRect]()[dimension] < self.bMin) {\\n                a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px'\\n                b.style[dimension] = (self.bMin - self.bGutterSize) + 'px'\\n            }\\n        }\\n      , fitMinReverse = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (b[getBoundingClientRect]()[dimension] < self.bMin) {\\n                a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px'\\n                b.style[dimension] = (self.bMin - self.bGutterSize) + 'px'\\n            } else if (a[getBoundingClientRect]()[dimension] < self.aMin) {\\n                a.style[dimension] = (self.aMin - self.aGutterSize) + 'px'\\n                b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px'\\n            }\\n        }\\n      , balancePairs = function (pairs) {\\n            for (var i = 0; i < pairs.length; i++) {\\n                calculateSizes.call(pairs[i])\\n                fitMin.call(pairs[i])\\n            }\\n\\n            for (i = pairs.length - 1; i >= 0; i--) {\\n                calculateSizes.call(pairs[i])\\n                fitMinReverse.call(pairs[i])\\n            }\\n        }\\n      , setElementSize = function (el, size, gutterSize) {\\n            // Split.js allows setting sizes via numbers (ideally), or if you must,\\n            // by string, like '300px'. This is less than ideal, because it breaks\\n            // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\\n            // make sure you calculate the gutter size by hand.\\n            if (typeof size !== 'string' && !(size instanceof String)) {\\n                if (!isIE8) {\\n                    size = calc + '(' + size + '% - ' + gutterSize + 'px)'\\n                } else {\\n                    size = options.sizes[i] + '%'\\n                }\\n            }\\n\\n            el.style[dimension] = size\\n        }\\n\\n      // No-op function to prevent default. Used to prevent selection.\\n      , noop = function () { return false }\\n\\n      // All DOM elements in the split should have a common parent. We can grab\\n      // the first elements parent and hope users read the docs because the\\n      // behavior will be whacky otherwise.\\n      , parent = elementOrSelector(ids[0]).parentNode\\n\\n    // Set default options.sizes to equal percentages of the parent element.\\n    if (!options.sizes) {\\n        var percent = 100 / ids.length\\n\\n        options.sizes = []\\n\\n        for (i = 0; i < ids.length; i++) {\\n            options.sizes.push(percent)\\n        }\\n    }\\n\\n    // Standardize minSize to an array if it isn't already. This allows minSize\\n    // to be passed as a number.\\n    if (!Array.isArray(options.minSize)) {\\n        var minSizes = []\\n\\n        for (i = 0; i < ids.length; i++) {\\n            minSizes.push(options.minSize)\\n        }\\n\\n        options.minSize = minSizes\\n    }\\n\\n    // 5. Loop through the elements while pairing them off. Every pair gets a\\n    // `pair` object, a gutter, and isFirst/isLast properties.\\n    //\\n    // Basic logic:\\n    //\\n    // - Starting with the second element `i > 0`, create `pair` objects with\\n    //   `a = ids[i - 1]` and `b = ids[i]`\\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\\n    // - Create gutter elements and add event listeners.\\n    // - Set the size of the elements, minus the gutter sizes.\\n    //\\n    // -----------------------------------------------------------------------\\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\\n    // |             |       isFirst       |                  |     isLast   |\\n    // |           pair 0                pair 1             pair 2           |\\n    // |             |                     |                  |              |\\n    // -----------------------------------------------------------------------\\n    for (i = 0; i < ids.length; i++) {\\n        var el = elementOrSelector(ids[i])\\n          , isFirstPair = (i == 1)\\n          , isLastPair = (i == ids.length - 1)\\n          , size = options.sizes[i]\\n          , gutterSize = options.gutterSize\\n          , pair\\n\\n        if (i > 0) {\\n            // Create the pair object with it's metadata.\\n            pair = {\\n                a: elementOrSelector(ids[i - 1]),\\n                b: el,\\n                aMin: options.minSize[i - 1],\\n                bMin: options.minSize[i],\\n                dragging: false,\\n                parent: parent,\\n                isFirst: isFirstPair,\\n                isLast: isLastPair,\\n                direction: options.direction\\n            }\\n\\n            // For first and last pairs, first and last gutter width is half.\\n            pair.aGutterSize = options.gutterSize\\n            pair.bGutterSize = options.gutterSize\\n\\n            if (isFirstPair) {\\n                pair.aGutterSize = options.gutterSize / 2\\n            }\\n\\n            if (isLastPair) {\\n                pair.bGutterSize = options.gutterSize / 2\\n            }\\n        }\\n\\n        // Determine the size of the current element. IE8 is supported by\\n        // staticly assigning sizes without draggable gutters. Assigns a string\\n        // to `size`.\\n        // \\n        // IE9 and above\\n        if (!isIE8) {\\n            // Create gutter elements for each pair.\\n            if (i > 0) {\\n                var gutter = document.createElement('div')\\n\\n                gutter.className = gutterClass\\n                gutter.style[dimension] = options.gutterSize + 'px'\\n\\n                gutter[addEventListener]('mousedown', startDragging.bind(pair))\\n                gutter[addEventListener]('touchstart', startDragging.bind(pair))\\n\\n                parent.insertBefore(gutter, el)\\n\\n                pair.gutter = gutter\\n            }\\n\\n            // Half-size gutters for first and last elements.\\n            if (i === 0 || i == ids.length - 1) {\\n                gutterSize = options.gutterSize / 2\\n            }\\n        }\\n\\n        // Set the element size to our determined size.\\n        setElementSize(el, size, gutterSize)\\n\\n        // After the first iteration, and we have a pair object, append it to the\\n        // list of pairs.\\n        if (i > 0) {\\n            pairs.push(pair)\\n        }\\n    }\\n\\n    // Balance the pairs to try to accomodate min sizes.\\n    balancePairs(pairs)\\n\\n    return {\\n        setSizes: function (sizes) {\\n            for (var i = 0; i < sizes.length; i++) {\\n                if (i > 0) {\\n                    var pair = pairs[i - 1]\\n\\n                    setElementSize(pair.a, sizes[i - 1], pair.aGutterSize)\\n                    setElementSize(pair.b, sizes[i], pair.bGutterSize)\\n                }\\n            }\\n        },\\n        collapse: function (i) {\\n            var pair\\n\\n            if (i === pairs.length) {\\n                pair = pairs[i - 1]\\n\\n                calculateSizes.call(pair)\\n                adjust.call(pair, pair.size - pair.bGutterSize)\\n            } else {\\n                pair = pairs[i]\\n\\n                calculateSizes.call(pair)\\n                adjust.call(pair, pair.aGutterSize)\\n            }\\n        },\\n        destroy: function () {\\n            for (var i = 0; i < pairs.length; i++) {\\n                pairs[i].parent.removeChild(pairs[i].gutter)\\n                pairs[i].a.style[dimension] = ''\\n                pairs[i].b.style[dimension] = ''\\n            }\\n        }\\n    }\\n}\\n\\n// Play nicely with module systems, and the browser too if you include it raw.\\nif (typeof exports !== 'undefined') {\\n    if (typeof module !== 'undefined' && module.exports) {\\n        exports = module.exports = Split\\n    }\\n    exports.Split = Split\\n} else {\\n    global.Split = Split\\n}\\n\\n// Call our wrapper function with the current global. In this case, `window`.\\n}).call(window);\\n\"\n\n/***/ },\n\n/***/ 613:\n/***/ function(module, exports) {\n\n/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n/***/ },\n\n/***/ 617:\n/***/ function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(334);\n\n\n/***/ }\n\n},[617]);\n\n\n// WEBPACK FOOTER //\n// scripts.c1644f851edaba09829d.bundle.js","require(\"!!/home/adebisi/Public/testCli/node_modules/script-loader/addScript.js\")(require(\"!!/home/adebisi/Public/testCli/node_modules/raw-loader/index.js!/home/adebisi/Public/testCli/node_modules/split.js/split.js\"))\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/adebisi/Public/testCli/~/split.js/split.js\n// module id = 334\n// module chunks = 2","module.exports = \"// The programming goals of Split.js are to deliver readable, understandable and\\n// maintainable code, while at the same time manually optimizing for tiny minified file size,\\n// browser compatibility without additional requirements, graceful fallback (IE8 is supported)\\n// and very few assumptions about the user's page layout.\\n//\\n// Make sure all browsers handle this JS library correctly with ES5.\\n// More information here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode\\n'use strict';\\n\\n// A wrapper function that does a couple things:\\n//\\n// 1. Doesn't pollute the global namespace. This is important for a library.\\n// 2. Allows us to mount the library in different module systems, as well as\\n//    directly in the browser.\\n(function() {\\n\\n// Save the global `this` for use later. In this case, since the library only\\n// runs in the browser, it will refer to `window`. Also, figure out if we're in IE8\\n// or not. IE8 will still render correctly, but will be static instead of draggable.\\n//\\n// Save a couple long function names that are used frequently.\\n// This optimization saves around 400 bytes.\\nvar global = this\\n  , isIE8 = global.attachEvent && !global[addEventListener]\\n  , document = global.document\\n  , addEventListener = 'addEventListener'\\n  , removeEventListener = 'removeEventListener'\\n  , getBoundingClientRect = 'getBoundingClientRect'\\n\\n  // This library only needs two helper functions:\\n  //\\n  // The first determines which prefixes of CSS calc we need.\\n  // We only need to do this once on startup, when this anonymous function is called.\\n  // \\n  // Tests -webkit, -moz and -o prefixes. Modified from StackOverflow:\\n  // http://stackoverflow.com/questions/16625140/js-feature-detection-to-detect-the-usage-of-webkit-calc-over-calc/16625167#16625167\\n  , calc = (function () {\\n        var el\\n          , prefixes = [\\\"\\\", \\\"-webkit-\\\", \\\"-moz-\\\", \\\"-o-\\\"]\\n\\n        for (var i = 0; i < prefixes.length; i++) {\\n            el = document.createElement('div')\\n            el.style.cssText = \\\"width:\\\" + prefixes[i] + \\\"calc(9px)\\\"\\n\\n            if (el.style.length) {\\n                return prefixes[i] + \\\"calc\\\"\\n            }\\n        }\\n    })()\\n\\n  // The second helper function allows elements and string selectors to be used\\n  // interchangeably. In either case an element is returned. This allows us to\\n  // do `Split(elem1, elem2)` as well as `Split('#id1', '#id2')`.\\n  , elementOrSelector = function (el) {\\n        if (typeof el === 'string' || el instanceof String) {\\n            return document.querySelector(el)\\n        } else {\\n            return el\\n        }\\n    }\\n\\n  // The main function to initialize a split. Split.js thinks about each pair\\n  // of elements as an independant pair. Dragging the gutter between two elements\\n  // only changes the dimensions of elements in that pair. This is key to understanding\\n  // how the following functions operate, since each function is bound to a pair.\\n  // \\n  // A pair object is shaped like this:\\n  // \\n  // {\\n  //     a: DOM element,\\n  //     b: DOM element,\\n  //     aMin: Number,\\n  //     bMin: Number,\\n  //     dragging: Boolean,\\n  //     parent: DOM element,\\n  //     isFirst: Boolean,\\n  //     isLast: Boolean,\\n  //     direction: 'horizontal' | 'vertical'\\n  // }\\n  //\\n  // The basic sequence:\\n  // \\n  // 1. Set defaults to something sane. `options` doesn't have to be passed at all.\\n  // 2. Initialize a bunch of strings based on the direction we're splitting.\\n  //    A lot of the behavior in the rest of the library is paramatized down to\\n  //    rely on CSS strings and classes.\\n  // 3. Define the dragging helper functions, and a few helpers to go with them.\\n  // 4. Define a few more functions that \\\"balance\\\" the entire split instance.\\n  //    Split.js tries it's best to cope with min sizes that don't add up.\\n  // 5. Loop through the elements while pairing them off. Every pair gets an\\n  //    `pair` object, a gutter, and special isFirst/isLast properties.\\n  // 6. Actually size the pair elements, insert gutters and attach event listeners.\\n  // 7. Balance all of the pairs to accomodate min sizes as best as possible.\\n  , Split = function (ids, options) {\\n    var dimension\\n      , i\\n      , clientDimension\\n      , clientAxis\\n      , position\\n      , gutterClass\\n      , paddingA\\n      , paddingB\\n      , pairs = []\\n\\n    // 1. Set defaults to something sane. `options` doesn't have to be passed at all,\\n    // so create an options object if none exists. Pixel values 10, 100 and 30 are\\n    // arbitrary but feel natural.\\n    options = typeof options !== 'undefined' ?  options : {}\\n\\n    if (typeof options.gutterSize === 'undefined') options.gutterSize = 10\\n    if (typeof options.minSize === 'undefined') options.minSize = 100\\n    if (typeof options.snapOffset === 'undefined') options.snapOffset = 30\\n    if (typeof options.direction === 'undefined') options.direction = 'horizontal'\\n\\n    // 2. Initialize a bunch of strings based on the direction we're splitting.\\n    // A lot of the behavior in the rest of the library is paramatized down to\\n    // rely on CSS strings and classes.\\n    if (options.direction == 'horizontal') {\\n        dimension = 'width'\\n        clientDimension = 'clientWidth'\\n        clientAxis = 'clientX'\\n        position = 'left'\\n        gutterClass = 'gutter gutter-horizontal'\\n        paddingA = 'paddingLeft'\\n        paddingB = 'paddingRight'\\n        if (!options.cursor) options.cursor = 'ew-resize'\\n    } else if (options.direction == 'vertical') {\\n        dimension = 'height'\\n        clientDimension = 'clientHeight'\\n        clientAxis = 'clientY'\\n        position = 'top'\\n        gutterClass = 'gutter gutter-vertical'\\n        paddingA = 'paddingTop'\\n        paddingB = 'paddingBottom'\\n        if (!options.cursor) options.cursor = 'ns-resize'\\n    }\\n\\n    // 3. Define the dragging helper functions, and a few helpers to go with them.\\n    // Each helper is bound to a pair object that contains it's metadata. This\\n    // also makes it easy to store references to listeners that that will be\\n    // added and removed.\\n    // \\n    // Even though there are no other functions contained in them, aliasing\\n    // this to self saves 50 bytes or so since it's used so frequently.\\n    //\\n    // The pair object saves metadata like dragging state, position and\\n    // event listener references.\\n    //\\n    // startDragging calls `calculateSizes` to store the inital size in the pair object.\\n    // It also adds event listeners for mouse/touch events,\\n    // and prevents selection while dragging so avoid the selecting text.\\n    var startDragging = function (e) {\\n            // Alias frequently used variables to save space. 200 bytes.\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            // Call the onDragStart callback.\\n            if (!self.dragging && options.onDragStart) {\\n                options.onDragStart()\\n            }\\n\\n            // Don't actually drag the element. We emulate that in the drag function.\\n            e.preventDefault()\\n\\n            // Set the dragging property of the pair object.\\n            self.dragging = true\\n\\n            // Create two event listeners bound to the same pair object and store\\n            // them in the pair object.\\n            self.move = drag.bind(self)\\n            self.stop = stopDragging.bind(self)\\n\\n            // All the binding. `window` gets the stop events in case we drag out of the elements.\\n            global[addEventListener]('mouseup', self.stop)\\n            global[addEventListener]('touchend', self.stop)\\n            global[addEventListener]('touchcancel', self.stop)\\n\\n            self.parent[addEventListener]('mousemove', self.move)\\n            self.parent[addEventListener]('touchmove', self.move)\\n\\n            // Disable selection. Disable!\\n            a[addEventListener]('selectstart', noop)\\n            a[addEventListener]('dragstart', noop)\\n            b[addEventListener]('selectstart', noop)\\n            b[addEventListener]('dragstart', noop)\\n\\n            a.style.userSelect = 'none'\\n            a.style.webkitUserSelect = 'none'\\n            a.style.MozUserSelect = 'none'\\n            a.style.pointerEvents = 'none'\\n\\n            b.style.userSelect = 'none'\\n            b.style.webkitUserSelect = 'none'\\n            b.style.MozUserSelect = 'none'\\n            b.style.pointerEvents = 'none'\\n\\n            // Set the cursor, both on the gutter and the parent element.\\n            // Doing only a, b and gutter causes flickering.\\n            self.gutter.style.cursor = options.cursor\\n            self.parent.style.cursor = options.cursor\\n\\n            // Cache the initial sizes of the pair.\\n            calculateSizes.call(self)\\n        }\\n\\n      // stopDragging is very similar to startDragging in reverse.\\n      , stopDragging = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (self.dragging && options.onDragEnd) {\\n                options.onDragEnd()\\n            }\\n\\n            self.dragging = false\\n\\n            // Remove the stored event listeners. This is why we store them.\\n            global[removeEventListener]('mouseup', self.stop)\\n            global[removeEventListener]('touchend', self.stop)\\n            global[removeEventListener]('touchcancel', self.stop)\\n\\n            self.parent[removeEventListener]('mousemove', self.move)\\n            self.parent[removeEventListener]('touchmove', self.move)\\n\\n            // Delete them once they are removed. I think this makes a difference\\n            // in memory usage with a lot of splits on one page. But I don't know for sure.\\n            delete self.stop\\n            delete self.move\\n\\n            a[removeEventListener]('selectstart', noop)\\n            a[removeEventListener]('dragstart', noop)\\n            b[removeEventListener]('selectstart', noop)\\n            b[removeEventListener]('dragstart', noop)\\n\\n            a.style.userSelect = ''\\n            a.style.webkitUserSelect = ''\\n            a.style.MozUserSelect = ''\\n            a.style.pointerEvents = ''\\n\\n            b.style.userSelect = ''\\n            b.style.webkitUserSelect = ''\\n            b.style.MozUserSelect = ''\\n            b.style.pointerEvents = ''\\n\\n            self.gutter.style.cursor = ''\\n            self.parent.style.cursor = ''\\n        }\\n\\n      // drag, where all the magic happens. The logic is really quite simple:\\n      // \\n      // 1. Ignore if the pair is not dragging.\\n      // 2. Get the offset of the event.\\n      // 3. Snap offset to min if within snappable range (within min + snapOffset).\\n      // 4. Actually adjust each element in the pair to offset.\\n      // \\n      // ---------------------------------------------------------------------\\n      // |    | <- this.aMin               ||              this.bMin -> |    |\\n      // |    |  | <- this.snapOffset      ||     this.snapOffset -> |  |    |\\n      // |    |  |                         ||                        |  |    |\\n      // |    |  |                         ||                        |  |    |\\n      // ---------------------------------------------------------------------\\n      // | <- this.start                                        this.size -> |\\n      , drag = function (e) {\\n            var offset\\n\\n            if (!this.dragging) return\\n\\n            // Get the offset of the event from the first side of the\\n            // pair `this.start`. Supports touch events, but not multitouch, so only the first\\n            // finger `touches[0]` is counted.\\n            if ('touches' in e) {\\n                offset = e.touches[0][clientAxis] - this.start\\n            } else {\\n                offset = e[clientAxis] - this.start\\n            }\\n\\n            // If within snapOffset of min or max, set offset to min or max.\\n            // snapOffset buffers aMin and bMin, so logic is opposite for both.\\n            // Include the appropriate gutter sizes to prevent overflows.\\n            if (offset <= this.aMin + options.snapOffset + this.aGutterSize) {\\n                offset = this.aMin + this.aGutterSize\\n            } else if (offset >= this.size - (this.bMin + options.snapOffset + this.bGutterSize)) {\\n                offset = this.size - (this.bMin + this.bGutterSize)\\n            }\\n\\n            // Actually adjust the size.\\n            adjust.call(this, offset)\\n\\n            // Call the drag callback continously. Don't do anything too intensive\\n            // in this callback.\\n            if (options.onDrag) {\\n                options.onDrag()\\n            }\\n        }\\n\\n      // Cache some important sizes when drag starts, so we don't have to do that\\n      // continously:\\n      // \\n      // `size`: The total size of the pair. First element + second element + first gutter + second gutter.\\n      // `percentage`: The percentage between 0-100 that the pair occupies in the parent.\\n      // `start`: The leading side of the first element.\\n      //\\n      // ------------------------------------------------ - - - - - - - - - - -\\n      // |      aGutterSize -> |||                      |                     |\\n      // |                     |||                      |                     |\\n      // |                     |||                      |                     |\\n      // |                     ||| <- bGutterSize       |                     |\\n      // ------------------------------------------------ - - - - - - - - - - -\\n      // | <- start                             size -> |       parentSize -> |\\n      , calculateSizes = function () {\\n            // Figure out the parent size minus padding.\\n            var computedStyle = global.getComputedStyle(this.parent)\\n              , parentSize = this.parent[clientDimension] - parseFloat(computedStyle[paddingA]) - parseFloat(computedStyle[paddingB])\\n\\n            this.size = this.a[getBoundingClientRect]()[dimension] + this.b[getBoundingClientRect]()[dimension] + this.aGutterSize + this.bGutterSize\\n            this.percentage = Math.min(this.size / parentSize * 100, 100)\\n            this.start = this.a[getBoundingClientRect]()[position]\\n        }\\n\\n      // Actually adjust the size of elements `a` and `b` to `offset` while dragging.\\n      // calc is used to allow calc(percentage + gutterpx) on the whole split instance,\\n      // which allows the viewport to be resized without additional logic.\\n      // Element a's size is the same as offset. b's size is total size - a size.\\n      // Both sizes are calculated from the initial parent percentage, then the gutter size is subtracted.\\n      , adjust = function (offset) {\\n            this.a.style[dimension] = calc + '(' + (offset / this.size * this.percentage) + '% - ' + this.aGutterSize + 'px)'\\n            this.b.style[dimension] = calc + '(' + (this.percentage - (offset / this.size * this.percentage)) + '% - ' + this.bGutterSize + 'px)'\\n        }\\n\\n      // 4. Define a few more functions that \\\"balance\\\" the entire split instance.\\n      // Split.js tries it's best to cope with min sizes that don't add up.\\n      // At some point this should go away since it breaks out of the calc(% - px) model.\\n      // Maybe it's a user error if you pass uncomputable minSizes.\\n      , fitMin = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (a[getBoundingClientRect]()[dimension] < self.aMin) {\\n                a.style[dimension] = (self.aMin - self.aGutterSize) + 'px'\\n                b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px'\\n            } else if (b[getBoundingClientRect]()[dimension] < self.bMin) {\\n                a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px'\\n                b.style[dimension] = (self.bMin - self.bGutterSize) + 'px'\\n            }\\n        }\\n      , fitMinReverse = function () {\\n            var self = this\\n              , a = self.a\\n              , b = self.b\\n\\n            if (b[getBoundingClientRect]()[dimension] < self.bMin) {\\n                a.style[dimension] = (self.size - self.bMin - self.bGutterSize) + 'px'\\n                b.style[dimension] = (self.bMin - self.bGutterSize) + 'px'\\n            } else if (a[getBoundingClientRect]()[dimension] < self.aMin) {\\n                a.style[dimension] = (self.aMin - self.aGutterSize) + 'px'\\n                b.style[dimension] = (self.size - self.aMin - self.aGutterSize) + 'px'\\n            }\\n        }\\n      , balancePairs = function (pairs) {\\n            for (var i = 0; i < pairs.length; i++) {\\n                calculateSizes.call(pairs[i])\\n                fitMin.call(pairs[i])\\n            }\\n\\n            for (i = pairs.length - 1; i >= 0; i--) {\\n                calculateSizes.call(pairs[i])\\n                fitMinReverse.call(pairs[i])\\n            }\\n        }\\n      , setElementSize = function (el, size, gutterSize) {\\n            // Split.js allows setting sizes via numbers (ideally), or if you must,\\n            // by string, like '300px'. This is less than ideal, because it breaks\\n            // the fluid layout that `calc(% - px)` provides. You're on your own if you do that,\\n            // make sure you calculate the gutter size by hand.\\n            if (typeof size !== 'string' && !(size instanceof String)) {\\n                if (!isIE8) {\\n                    size = calc + '(' + size + '% - ' + gutterSize + 'px)'\\n                } else {\\n                    size = options.sizes[i] + '%'\\n                }\\n            }\\n\\n            el.style[dimension] = size\\n        }\\n\\n      // No-op function to prevent default. Used to prevent selection.\\n      , noop = function () { return false }\\n\\n      // All DOM elements in the split should have a common parent. We can grab\\n      // the first elements parent and hope users read the docs because the\\n      // behavior will be whacky otherwise.\\n      , parent = elementOrSelector(ids[0]).parentNode\\n\\n    // Set default options.sizes to equal percentages of the parent element.\\n    if (!options.sizes) {\\n        var percent = 100 / ids.length\\n\\n        options.sizes = []\\n\\n        for (i = 0; i < ids.length; i++) {\\n            options.sizes.push(percent)\\n        }\\n    }\\n\\n    // Standardize minSize to an array if it isn't already. This allows minSize\\n    // to be passed as a number.\\n    if (!Array.isArray(options.minSize)) {\\n        var minSizes = []\\n\\n        for (i = 0; i < ids.length; i++) {\\n            minSizes.push(options.minSize)\\n        }\\n\\n        options.minSize = minSizes\\n    }\\n\\n    // 5. Loop through the elements while pairing them off. Every pair gets a\\n    // `pair` object, a gutter, and isFirst/isLast properties.\\n    //\\n    // Basic logic:\\n    //\\n    // - Starting with the second element `i > 0`, create `pair` objects with\\n    //   `a = ids[i - 1]` and `b = ids[i]`\\n    // - Set gutter sizes based on the _pair_ being first/last. The first and last\\n    //   pair have gutterSize / 2, since they only have one half gutter, and not two.\\n    // - Create gutter elements and add event listeners.\\n    // - Set the size of the elements, minus the gutter sizes.\\n    //\\n    // -----------------------------------------------------------------------\\n    // |     i=0     |         i=1         |        i=2       |      i=3     |\\n    // |             |       isFirst       |                  |     isLast   |\\n    // |           pair 0                pair 1             pair 2           |\\n    // |             |                     |                  |              |\\n    // -----------------------------------------------------------------------\\n    for (i = 0; i < ids.length; i++) {\\n        var el = elementOrSelector(ids[i])\\n          , isFirstPair = (i == 1)\\n          , isLastPair = (i == ids.length - 1)\\n          , size = options.sizes[i]\\n          , gutterSize = options.gutterSize\\n          , pair\\n\\n        if (i > 0) {\\n            // Create the pair object with it's metadata.\\n            pair = {\\n                a: elementOrSelector(ids[i - 1]),\\n                b: el,\\n                aMin: options.minSize[i - 1],\\n                bMin: options.minSize[i],\\n                dragging: false,\\n                parent: parent,\\n                isFirst: isFirstPair,\\n                isLast: isLastPair,\\n                direction: options.direction\\n            }\\n\\n            // For first and last pairs, first and last gutter width is half.\\n            pair.aGutterSize = options.gutterSize\\n            pair.bGutterSize = options.gutterSize\\n\\n            if (isFirstPair) {\\n                pair.aGutterSize = options.gutterSize / 2\\n            }\\n\\n            if (isLastPair) {\\n                pair.bGutterSize = options.gutterSize / 2\\n            }\\n        }\\n\\n        // Determine the size of the current element. IE8 is supported by\\n        // staticly assigning sizes without draggable gutters. Assigns a string\\n        // to `size`.\\n        // \\n        // IE9 and above\\n        if (!isIE8) {\\n            // Create gutter elements for each pair.\\n            if (i > 0) {\\n                var gutter = document.createElement('div')\\n\\n                gutter.className = gutterClass\\n                gutter.style[dimension] = options.gutterSize + 'px'\\n\\n                gutter[addEventListener]('mousedown', startDragging.bind(pair))\\n                gutter[addEventListener]('touchstart', startDragging.bind(pair))\\n\\n                parent.insertBefore(gutter, el)\\n\\n                pair.gutter = gutter\\n            }\\n\\n            // Half-size gutters for first and last elements.\\n            if (i === 0 || i == ids.length - 1) {\\n                gutterSize = options.gutterSize / 2\\n            }\\n        }\\n\\n        // Set the element size to our determined size.\\n        setElementSize(el, size, gutterSize)\\n\\n        // After the first iteration, and we have a pair object, append it to the\\n        // list of pairs.\\n        if (i > 0) {\\n            pairs.push(pair)\\n        }\\n    }\\n\\n    // Balance the pairs to try to accomodate min sizes.\\n    balancePairs(pairs)\\n\\n    return {\\n        setSizes: function (sizes) {\\n            for (var i = 0; i < sizes.length; i++) {\\n                if (i > 0) {\\n                    var pair = pairs[i - 1]\\n\\n                    setElementSize(pair.a, sizes[i - 1], pair.aGutterSize)\\n                    setElementSize(pair.b, sizes[i], pair.bGutterSize)\\n                }\\n            }\\n        },\\n        collapse: function (i) {\\n            var pair\\n\\n            if (i === pairs.length) {\\n                pair = pairs[i - 1]\\n\\n                calculateSizes.call(pair)\\n                adjust.call(pair, pair.size - pair.bGutterSize)\\n            } else {\\n                pair = pairs[i]\\n\\n                calculateSizes.call(pair)\\n                adjust.call(pair, pair.aGutterSize)\\n            }\\n        },\\n        destroy: function () {\\n            for (var i = 0; i < pairs.length; i++) {\\n                pairs[i].parent.removeChild(pairs[i].gutter)\\n                pairs[i].a.style[dimension] = ''\\n                pairs[i].b.style[dimension] = ''\\n            }\\n        }\\n    }\\n}\\n\\n// Play nicely with module systems, and the browser too if you include it raw.\\nif (typeof exports !== 'undefined') {\\n    if (typeof module !== 'undefined' && module.exports) {\\n        exports = module.exports = Split\\n    }\\n    exports.Split = Split\\n} else {\\n    global.Split = Split\\n}\\n\\n// Call our wrapper function with the current global. In this case, `window`.\\n}).call(window);\\n\"\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/adebisi/Public/testCli/~/raw-loader!/home/adebisi/Public/testCli/~/split.js/split.js\n// module id = 593\n// module chunks = 2","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// /home/adebisi/Public/testCli/~/script-loader/addScript.js\n// module id = 613\n// module chunks = 2"],"sourceRoot":""}